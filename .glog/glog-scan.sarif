{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-7f85b96b-0365-4475-a5a7-84ae994e6b6d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the multiplication `width*height*sizeof(int)` results in an integer overflow, the allocated memory block will be smaller than expected, leading to a buffer overflow vulnerability when this memory is used.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always check the result of the multiplication for overflow before passing it to `malloc`. If an overflow is detected, the program should handle it gracefully, for example by returning an error or by limiting the values of width and height so that the multiplication does not overflow.\n\n## Source Code Fix Recommendation\n\nHere is a simple way to check for overflow:\n\n```cpp\n#include <climits>\n#include <cstdlib>\n\nif (width && height > INT_MAX / width / sizeof(int)) {\n    // handle overflow, e.g. by returning an error\n} else {\n    int* array = (int*) malloc(width * height * sizeof(int));\n    if (array == NULL) {\n        // handle failed allocation\n    } else {\n        // use array\n        free(array);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `climits` for `INT_MAX`\n- `cstdlib` for `malloc` and `free`\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerability Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1e41748c-4571-4d92-aca9-61b3e29fd78a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the multiplication `width*height*sizeof(int)` results in an integer overflow, the allocated memory block will be smaller than expected, leading to a buffer overflow vulnerability when this memory is used.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always check the result of the multiplication for overflow before passing it to `malloc`. If an overflow is detected, the program should handle it gracefully, for example by returning an error or by limiting the values of width and height so that the multiplication does not overflow.\n\n## Source Code Fix Recommendation\n\nHere is a simple way to check for overflow:\n\n```cpp\n#include <climits>\n#include <cstdlib>\n\nif (width && height > INT_MAX / width / sizeof(int)) {\n    // handle overflow, e.g. by returning an error\n} else {\n    int* array = (int*) malloc(width * height * sizeof(int));\n    if (array == NULL) {\n        // handle failed allocation\n    } else {\n        // use array\n        free(array);\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `climits` for `INT_MAX`\n- `cstdlib` for `malloc` and `free`\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerability Guide](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-680: Integer Overflow to Buffer Overflow](https://cwe.mitre.org/data/definitions/680.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4f0a3658-d8ed-4066-a43d-059eae2cb008",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the multiplication `width * height * sizeof(int)` results in an integer overflow, the allocated memory block will be smaller than expected, leading to a buffer overflow vulnerability. This can lead to various security issues, including arbitrary code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always check the result of the multiplication for overflow before passing it to `malloc`. If an overflow is detected, you should handle it appropriately, for example by returning an error or by limiting the values of `width` and `height` so that the multiplication cannot overflow.\n\n## Source Code Fix Recommendation\n\nHere is a simple way to check for overflow:\n\n```cpp\nif (width && height && INT_MAX / width < height) {\n    // handle overflow, e.g. by returning an error\n} else {\n    int* array = (int*)malloc(width * height * sizeof(int));\n    if (array == NULL) {\n        // handle failed allocation\n    } else {\n        // use array\n    }\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc` function.\n\n## References\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1dae54de-c125-4b39-b839-8402867f8822",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(inputSizeBytes)` function in C++ is used to allocate a block of memory of specified size. It returns a pointer of type void which can be cast into a pointer of any form. The vulnerability arises when the size of the memory to be allocated is controlled by the user or an external input. This can lead to various security issues like buffer overflow, memory corruption, or Denial of Service (DoS) attacks.\n\n## Mitigation Advice\n\n1. **Input Validation**: Always validate the user input before using it in memory allocation functions. Make sure the size is within the acceptable range.\n\n2. **Error Handling**: Always check the return value of `malloc()`. If it returns NULL, the memory allocation has failed.\n\n3. **Limit User Control**: As much as possible, limit the control a user has over the size of memory to be allocated.\n\n## Source Code Fix\n\nHere is a simple example of how to fix the vulnerability:\n\n```cpp\n#include <stdlib.h>\n\n// ... \n\nsize_t inputSizeBytes;\n\n// Validate inputSizeBytes\nif(inputSizeBytes > MAX_SIZE || inputSizeBytes < MIN_SIZE) {\n    // Handle error\n}\n\nvoid* ptr = malloc(inputSizeBytes);\nif(ptr == NULL) {\n    // Handle error\n}\n\n// ...\n```\n\nIn this example, `MAX_SIZE` and `MIN_SIZE` are the maximum and minimum acceptable sizes for memory allocation. They should be defined according to the specific requirements of your program.\n\n## Library Dependencies\n\nThe `malloc()` function is part of the `stdlib.h` library in C++. No additional libraries are needed for this function.\n\n## References\n\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-89a4c95f-7325-414e-a2fe-a695231982f7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(sizeBytes)` function in C++ is used to allocate a block of memory of specified size. It returns a pointer of type void which can be cast into a pointer of any form. If the space is insufficient, allocation fails and it returns a NULL pointer. The vulnerability arises when the size of the memory to be allocated is not properly validated or is manipulated to cause an overflow, leading to unexpected behavior, crashes, or potential code execution.\n\n## Mitigation Advice\n\n1. Always check the return value of `malloc()`. If it returns NULL, the memory allocation has failed.\n2. Validate and sanitize all inputs that are used to determine the size of the memory allocation.\n3. Avoid integer overflows which can lead to allocation of smaller memory blocks than expected.\n4. Use functions that limit the amount of memory allocated, such as `mallocarray()`.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <stdlib.h>\n\n// sizeBytes is the size of the memory to be allocated\nsize_t sizeBytes = 10;\n\n// Check for integer overflow\nif (sizeBytes > SIZE_MAX / sizeof(int)) {\n    // Handle error\n}\n\n// Allocate memory\nint* ptr = (int*) malloc(sizeBytes * sizeof(int));\n\n// Check if memory allocation was successful\nif (ptr == NULL) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the `stdlib.h` library in C++. No additional libraries are needed for this function.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5615c240-b078-486f-a7d6-12fbad222061",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(sizeBytes)` function in C++ is used to allocate a block of memory of specified size. It returns a pointer of type void which can be cast into a pointer of any form. If the space is insufficient, allocation fails and it returns a NULL pointer. The vulnerability arises when the size of the memory to be allocated is not properly validated or is manipulated to cause an overflow, leading to unexpected behavior, crashes, or potential code execution.\n\n## Mitigation Advice\n\n1. Always check the return value of `malloc()`. If it returns NULL, the memory allocation has failed.\n2. Validate and sanitize all inputs that are used to determine the size of the memory allocation.\n3. Avoid integer overflows which can lead to allocation of smaller memory blocks than expected.\n4. Use functions that limit the amount of memory allocated, such as `mallocarray()`.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <stdlib.h>\n\n// sizeBytes is the size of the memory to be allocated\nsize_t sizeBytes = 10;\n\n// Check for integer overflow\nif (sizeBytes > SIZE_MAX / sizeof(int)) {\n    // Handle error\n}\n\n// Allocate memory\nint* ptr = (int*) malloc(sizeBytes * sizeof(int));\n\n// Check if memory allocation was successful\nif (ptr == NULL) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the `stdlib.h` library in C++. No additional libraries are needed for this function.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-731923c0-df52-4f84-92a7-ff8efc399ca5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc(sizeBytes)` function in C++ is used to allocate a block of memory of specified size. It returns a pointer of type void which can be cast into a pointer of any form. If the space is insufficient, allocation fails and it returns a NULL pointer. The vulnerability arises when the size of the memory to be allocated is not properly validated or is manipulated to cause an overflow, leading to unexpected behavior, crashes, or potential code execution.\n\n## Mitigation Advice\n\n1. Always check the return value of `malloc()`. If it returns NULL, the memory allocation has failed.\n2. Validate and sanitize all inputs that are used to determine the size of the memory allocation.\n3. Avoid integer overflows which can lead to allocation of smaller memory blocks than expected.\n4. Use functions that limit the amount of memory allocated, such as `mallocarray()`.\n\n## Source Code Fix Recommendation\n\n```cpp\n#include <stdlib.h>\n\n// sizeBytes is the size of the memory to be allocated\nsize_t sizeBytes = 10;\n\n// Check for integer overflow\nif (sizeBytes > SIZE_MAX / sizeof(int)) {\n    // Handle error\n}\n\n// Allocate memory\nint* ptr = (int*) malloc(sizeBytes * sizeof(int));\n\n// Check if memory allocation was successful\nif (ptr == NULL) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the `stdlib.h` library in C++. No additional libraries are needed for this function.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6042dfe5-06c9-4a33-b556-e4f3d22f4448",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(inData, temp, signalLength * sizeof(float))`, if `signalLength * sizeof(float)` is larger than the size of `inData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, system crashes, and unauthorized code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = signalLength * sizeof(float);\nif (sizeof(inData) >= size) {\n    memcpy(inData, temp, size);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\nIn this fixed code, we first calculate the size of the data being copied. Then we check if the size of the destination buffer `inData` is larger or equal to this size. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not be accessible at all times."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-69ab1114-3b19-4a79-ad2b-ac18730475cb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `curSignalLength * sizeof(float)` is larger than the size of `hOutData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker can exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = curSignalLength * sizeof(float);\nif (sizeof(hOutData) >= size) {\n    memcpy(hOutData, dOutData, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data being copied and then check if the destination buffer is large enough to hold this data. If it is, we proceed with the `memcpy`. If it's not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2dac131f-fa71-4d68-af3d-1afc972ff02a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is `(one << levels)`, which could potentially be larger than the size of `inData`, leading to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to a variety of security issues, including arbitrary code execution, denial of service, and information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include a size parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nsize_t size = (one << levels);\nif (size <= sizeof(inData)) {\n    memcpy(inData, dPartialOutData, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first calculate the size of the data being copied and then check if it is larger than the size of `inData`. If it is, we handle the error instead of calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional library dependencies are required for the provided code snippet.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0a4156c9-3607-4ff3-b360-2b402158ce97",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `signalLength * sizeof(float)` is larger than the size of `temp`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = signalLength * sizeof(float);\nif (sizeof(temp) >= size) {\n    memcpy(temp, inData, size);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the data being copied and then check if the destination buffer is large enough to hold it. If it is, we proceed with the copy. If not, we handle the error in an appropriate way.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-434d739b-17f2-4b14-b8d7-33c6c75c97a5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur in the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the destination buffer is smaller than the source buffer, it can lead to a buffer overflow, which can cause a program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied from the source buffer. This can be done by checking the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t size = (signalLength  - (one << curLevels));\nif (size <= sizeof(dOutData + (one << curLevels))) {\n    memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels), size);\n} else {\n    // Handle error\n}\n```\n\nIn this version of the code, we first calculate the size of the data to be copied and then check if the destination buffer is large enough to hold this data. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way (this will depend on the specifics of your program).\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d93091b6-f143-4acf-92c7-8f7752fa9051",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, the size of the data being copied is `(one << curLevels)`, which could potentially be larger than the size of `hOutData`, leading to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the size of the data being copied does not exceed the size of the destination buffer. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t dataSize = (one << curLevels);\nif (dataSize <= sizeof(hOutData)) {\n    memcpy(hOutData, dOutData, dataSize);\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first calculate the size of the data to be copied and then check if it is less than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific application.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C standard library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e4c0de0c-fe5f-427a-9280-979a83765a6f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a user input or another untrusted source, it can lead to several types of vulnerabilities, including buffer overflow, integer overflow, or even denial of service (DoS) if the requested size is excessively large.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize inputs: Never trust user input or any other untrusted source. Always validate and sanitize it before using it in your code.\n\n2. Use secure functions: Instead of `malloc`, consider using functions like `calloc`, which not only allocates memory but also initializes it to zero. This can help prevent issues like uninitialized variables.\n\n3. Handle errors: Always check if `malloc` was successful by checking if the returned pointer is not NULL. If `malloc` fails, it returns NULL and you should handle this error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t signalLength = /* some value */;\nfloat* signal = NULL;\n\nif (signalLength > 0 && signalLength <= MAX_SIGNAL_LENGTH) {\n    signal = (float*) malloc(signalLength * sizeof(float));\n    if (signal == NULL) {\n        // handle error\n    }\n} else {\n    // handle error\n}\n```\n\nIn this code, we first check if `signalLength` is within a valid range (0 to `MAX_SIGNAL_LENGTH`). Then, we call `malloc` and check if it was successful.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1eb3a1de-1f76-4008-8666-202f3eedf74b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a user input or another untrusted source, it can lead to several types of vulnerabilities, including buffer overflow, integer overflow, or even denial of service (DoS) if the requested size is excessively large.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize inputs: Never trust user input or any other untrusted source. Always validate and sanitize it before using it in your code.\n\n2. Use secure functions: Instead of `malloc`, consider using functions like `calloc`, which not only allocates memory but also initializes it to zero. This can help prevent issues like uninitialized variables.\n\n3. Handle errors: Always check if `malloc` was successful by checking if the returned pointer is not NULL. If `malloc` fails, it returns NULL and you should handle this error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t signalLength = /* some value */;\nfloat* signal = NULL;\n\nif (signalLength > 0 && signalLength <= MAX_SIGNAL_LENGTH) {\n    signal = (float*) malloc(signalLength * sizeof(float));\n    if (signal == NULL) {\n        // handle error\n    }\n} else {\n    // handle error\n}\n```\n\nIn this code, we first check if `signalLength` is within a valid range (0 to `MAX_SIGNAL_LENGTH`). Then, we call `malloc` and check if it was successful.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-df4b3f87-8b41-4aa2-ac9e-04760d656606",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a user input or another untrusted source, it can lead to several types of vulnerabilities, including buffer overflow, integer overflow, or even denial of service (DoS) if the requested size is excessively large.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize inputs: Never trust user input or any other untrusted source. Always validate and sanitize it before using it in your code.\n\n2. Use secure functions: Instead of `malloc`, consider using functions like `calloc`, which not only allocates memory but also initializes it to zero. This can help prevent issues like uninitialized variables.\n\n3. Handle errors: Always check if `malloc` was successful by checking if the returned pointer is not NULL. If `malloc` fails, it returns NULL and you should handle this error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t signalLength = /* some value */;\nfloat* signal = NULL;\n\nif (signalLength > 0 && signalLength <= MAX_SIGNAL_LENGTH) {\n    signal = (float*) malloc(signalLength * sizeof(float));\n    if (signal == NULL) {\n        // handle error\n    }\n} else {\n    // handle error\n}\n```\n\nIn this code, we first check if `signalLength` is within a valid range (0 to `MAX_SIGNAL_LENGTH`). Then, we call `malloc` and check if it was successful.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-b68c5061-cd94-41e3-8184-51ed457a073c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a user input or another untrusted source, it can lead to several types of vulnerabilities, including buffer overflow, integer overflow, or even denial of service (DoS) if the requested size is excessively large.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize inputs: Never trust user input or any other untrusted source. Always validate and sanitize it before using it in your code.\n\n2. Use secure functions: Instead of `malloc`, consider using functions like `calloc`, which not only allocates memory but also initializes it to zero. This can help prevent issues like uninitialized variables.\n\n3. Handle errors: Always check if `malloc` was successful by checking if the returned pointer is not NULL. If `malloc` fails, it returns NULL and you should handle this error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t signalLength = /* some value */;\nfloat* signal = NULL;\n\nif (signalLength > 0 && signalLength <= MAX_SIGNAL_LENGTH) {\n    signal = (float*) malloc(signalLength * sizeof(float));\n    if (signal == NULL) {\n        // handle error\n    }\n} else {\n    // handle error\n}\n```\n\nIn this code, we first check if `signalLength` is within a valid range (0 to `MAX_SIGNAL_LENGTH`). Then, we call `malloc` and check if it was successful.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6dab40a5-e4cc-4e8c-b081-542582088037",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. The size of this block is determined by the argument passed to the function. If the argument is a result of a user input or another untrusted source, it can lead to several types of vulnerabilities, including buffer overflow, integer overflow, or even denial of service (DoS) if the requested size is excessively large.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to:\n\n1. Always validate and sanitize inputs: Never trust user input or any other untrusted source. Always validate and sanitize it before using it in your code.\n\n2. Use secure functions: Instead of `malloc`, consider using functions like `calloc`, which not only allocates memory but also initializes it to zero. This can help prevent issues like uninitialized variables.\n\n3. Handle errors: Always check if `malloc` was successful by checking if the returned pointer is not NULL. If `malloc` fails, it returns NULL and you should handle this error appropriately.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the provided code:\n\n```cpp\n#include <stdlib.h>\n\n// ...\n\nsize_t signalLength = /* some value */;\nfloat* signal = NULL;\n\nif (signalLength > 0 && signalLength <= MAX_SIGNAL_LENGTH) {\n    signal = (float*) malloc(signalLength * sizeof(float));\n    if (signal == NULL) {\n        // handle error\n    }\n} else {\n    // handle error\n}\n```\n\nIn this code, we first check if `signalLength` is within a valid range (0 to `MAX_SIGNAL_LENGTH`). Then, we call `malloc` and check if it was successful.\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f7c0eeb5-ce97-4515-9d26-0bfe62d8cb0a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `signalLength * sizeof(float)` is larger than the size of `tempOutData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t size = signalLength * sizeof(float);\nif (sizeof(tempOutData) >= size) {\n    memcpy(tempOutData, hOutData, size);\n} else {\n    // Handle error\n}\n```\n\nIn this fix, we first calculate the size of the data being copied and then check if the destination buffer is large enough to hold this data. If it is, we proceed with the `memcpy`. If it isn't, we handle the error appropriately.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so the code snippet requires the `<cstring>` header file.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-eb21bd54-8c03-41e5-88aa-4d69684f52e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, if `signalLength * sizeof(float)` is larger than the size of `tempOutData`, it can lead to a buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues such as data corruption, crashes, and code execution. An attacker could exploit this vulnerability to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer and the size of the data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nsize_t bufferSize = sizeof(tempOutData);\nsize_t dataSize = signalLength * sizeof(float);\n\nif (dataSize <= bufferSize) {\n    memcpy(tempOutData, inData, dataSize);\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first calculate the size of the destination buffer and the size of the data. We then check if the data will fit into the buffer before calling `memcpy`.\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are needed for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-dc8eb536-d574-4e9e-9b83-1960f1afbebb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-5008dba4-d55e-451b-8014-b6633bc5e68b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-1e41748c-4571-4d92-aca9-61b3e29fd78a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                },
                "region": {
                  "startLine": 213,
                  "startColumn": 25,
                  "endLine": 213,
                  "endColumn": 56,
                  "charOffset": 7766,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(width*height*sizeof(int)",
                    "rendered": {
                      "text": "malloc(width*height*sizeof(int)",
                      "markdown": "`malloc(width*height*sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7766,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7f85b96b-0365-4475-a5a7-84ae994e6b6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 21,
                  "endLine": 211,
                  "endColumn": 52,
                  "charOffset": 7633,
                  "charLength": 31,
                  "snippet": {
                    "text": "malloc(width*height*sizeof(int)",
                    "rendered": {
                      "text": "malloc(width*height*sizeof(int)",
                      "markdown": "`malloc(width*height*sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7633,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4f0a3658-d8ed-4066-a43d-059eae2cb008",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                },
                "region": {
                  "startLine": 535,
                  "startColumn": 37,
                  "endLine": 535,
                  "endColumn": 72,
                  "charOffset": 18005,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(width * height * sizeof(int)",
                    "rendered": {
                      "text": "malloc(width * height * sizeof(int)",
                      "markdown": "`malloc(width * height * sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18005,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1dae54de-c125-4b39-b839-8402867f8822",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                },
                "region": {
                  "startLine": 209,
                  "startColumn": 30,
                  "endLine": 209,
                  "endColumn": 52,
                  "charOffset": 7516,
                  "charLength": 22,
                  "snippet": {
                    "text": "malloc(inputSizeBytes)",
                    "rendered": {
                      "text": "malloc(inputSizeBytes)",
                      "markdown": "`malloc(inputSizeBytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/SimpleConvolution/SimpleConvolution.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7516,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-89a4c95f-7325-414e-a2fe-a695231982f7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/PrefixSum/PrefixSum.cpp"
                },
                "region": {
                  "startLine": 321,
                  "startColumn": 39,
                  "endLine": 321,
                  "endColumn": 56,
                  "charOffset": 11850,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(sizeBytes)",
                    "rendered": {
                      "text": "malloc(sizeBytes)",
                      "markdown": "`malloc(sizeBytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/PrefixSum/PrefixSum.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11850,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5615c240-b078-486f-a7d6-12fbad222061",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/PrefixSum/PrefixSum.cpp"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 22,
                  "endLine": 313,
                  "endColumn": 39,
                  "charOffset": 11561,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(sizeBytes)",
                    "rendered": {
                      "text": "malloc(sizeBytes)",
                      "markdown": "`malloc(sizeBytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/PrefixSum/PrefixSum.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11561,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-731923c0-df52-4f84-92a7-ff8efc399ca5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/PrefixSum/PrefixSum.cpp"
                },
                "region": {
                  "startLine": 317,
                  "startColumn": 20,
                  "endLine": 317,
                  "endColumn": 37,
                  "charOffset": 11758,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(sizeBytes)",
                    "rendered": {
                      "text": "malloc(sizeBytes)",
                      "markdown": "`malloc(sizeBytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/PrefixSum/PrefixSum.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11758,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6042dfe5-06c9-4a33-b556-e4f3d22f4448",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 497,
                  "startColumn": 4,
                  "endLine": 497,
                  "endColumn": 53,
                  "charOffset": 15752,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(inData, temp, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(inData, temp, signalLength * sizeof(float)",
                      "markdown": "`memcpy(inData, temp, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15752,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(inData, <size of inData>,  temp,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-69ab1114-3b19-4a79-ad2b-ac18730475cb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 12,
                  "endLine": 489,
                  "endColumn": 70,
                  "charOffset": 15540,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(hOutData, dOutData, curSignalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(hOutData, dOutData, curSignalLength * sizeof(float)",
                      "markdown": "`memcpy(hOutData, dOutData, curSignalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15540,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hOutData, <size of hOutData>,  dOutData,  curSignalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2dac131f-fa71-4d68-af3d-1afc972ff02a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 490,
                  "startColumn": 12,
                  "endLine": 490,
                  "endColumn": 59,
                  "charOffset": 15613,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(inData, dPartialOutData, (one << levels)",
                    "rendered": {
                      "text": "memcpy(inData, dPartialOutData, (one << levels)",
                      "markdown": "`memcpy(inData, dPartialOutData, (one << levels)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15613,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(inData, <size of inData>,  dPartialOutData,  (one << levels)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0a4156c9-3607-4ff3-b360-2b402158ce97",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 4,
                  "endLine": 454,
                  "endColumn": 53,
                  "charOffset": 14523,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(temp, inData, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(temp, inData, signalLength * sizeof(float)",
                      "markdown": "`memcpy(temp, inData, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14523,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(temp, <size of temp>,  inData,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-434d739b-17f2-4b14-b8d7-33c6c75c97a5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 482,
                  "startColumn": 12,
                  "endLine": 483,
                  "endColumn": 54,
                  "charOffset": 15292,
                  "charLength": 123,
                  "snippet": {
                    "text": "memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels),\n                   (signalLength  - (one << curLevels)",
                    "rendered": {
                      "text": "memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels),\n                   (signalLength  - (one << curLevels)",
                      "markdown": "`memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels),\n                   (signalLength  - (one << curLevels)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15292,
                        "charLength": 123
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dOutData + (one << curLevels), <size of dOutData + (one << curLevels)>,  hOutData + (one << curLevels), \n                   (signalLength  - (one << curLevels)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d93091b6-f143-4acf-92c7-8f7752fa9051",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 481,
                  "startColumn": 12,
                  "endLine": 481,
                  "endColumn": 57,
                  "charOffset": 15216,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(hOutData, dOutData, (one << curLevels)",
                    "rendered": {
                      "text": "memcpy(hOutData, dOutData, (one << curLevels)",
                      "markdown": "`memcpy(hOutData, dOutData, (one << curLevels)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15216,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hOutData, <size of hOutData>,  dOutData,  (one << curLevels)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4c0de0c-fe5f-427a-9280-979a83765a6f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 360,
                  "startColumn": 23,
                  "endLine": 360,
                  "endColumn": 58,
                  "charOffset": 11824,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(signalLength * sizeof(float)",
                    "rendered": {
                      "text": "malloc(signalLength * sizeof(float)",
                      "markdown": "`malloc(signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11824,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1eb3a1de-1f76-4008-8666-202f3eedf74b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 349,
                  "startColumn": 24,
                  "endLine": 349,
                  "endColumn": 59,
                  "charOffset": 11383,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(signalLength * sizeof(float)",
                    "rendered": {
                      "text": "malloc(signalLength * sizeof(float)",
                      "markdown": "`malloc(signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11383,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-df4b3f87-8b41-4aa2-ac9e-04760d656606",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 453,
                  "startColumn": 26,
                  "endLine": 453,
                  "endColumn": 61,
                  "charOffset": 14481,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(signalLength * sizeof(float)",
                    "rendered": {
                      "text": "malloc(signalLength * sizeof(float)",
                      "markdown": "`malloc(signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14481,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b68c5061-cd94-41e3-8184-51ed457a073c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 341,
                  "startColumn": 21,
                  "endLine": 341,
                  "endColumn": 56,
                  "charOffset": 11140,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(signalLength * sizeof(float)",
                    "rendered": {
                      "text": "malloc(signalLength * sizeof(float)",
                      "markdown": "`malloc(signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11140,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6dab40a5-e4cc-4e8c-b081-542582088037",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 354,
                  "startColumn": 31,
                  "endLine": 354,
                  "endColumn": 66,
                  "charOffset": 11587,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(signalLength * sizeof(float)",
                    "rendered": {
                      "text": "malloc(signalLength * sizeof(float)",
                      "markdown": "`malloc(signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11587,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f7c0eeb5-ce97-4515-9d26-0bfe62d8cb0a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 8,
                  "endLine": 304,
                  "endColumn": 66,
                  "charOffset": 10322,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(tempOutData, hOutData, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(tempOutData, hOutData, signalLength * sizeof(float)",
                      "markdown": "`memcpy(tempOutData, hOutData, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10322,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tempOutData, <size of tempOutData>,  hOutData,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb21bd54-8c03-41e5-88aa-4d69684f52e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 4,
                  "endLine": 285,
                  "endColumn": 60,
                  "charOffset": 9714,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(tempOutData, inData, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(tempOutData, inData, signalLength * sizeof(float)",
                      "markdown": "`memcpy(tempOutData, inData, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9714,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tempOutData, <size of tempOutData>,  inData,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc8eb536-d574-4e9e-9b83-1960f1afbebb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 346,
                  "startColumn": 28,
                  "endLine": 346,
                  "endColumn": 33,
                  "charOffset": 11338,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-5008dba4-d55e-451b-8014-b6633bc5e68b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 346,
                  "startColumn": 28,
                  "endLine": 346,
                  "endColumn": 36,
                  "charOffset": 11338,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}