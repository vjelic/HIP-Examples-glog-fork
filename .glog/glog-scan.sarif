{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "de31a6c3-7a66-3214-95ec-7f7d93e68f1d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c0845fa9-c412-351e-b58b-c403a39ed912",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "efa97c47-6b33-3c61-8e64-d9c8dd0fc7fa",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2c435abc-93f5-31ca-a1a6-c7bfa16f9d52",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "b7b7edfb-718c-353f-9cf1-0e591083a053",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "b7b7edfb-718c-353f-9cf1-0e591083a053"
                ]
              }
            },
            {
              "id": "92501975-87a5-32fa-b281-0bc19e1e7d11",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced, making it unsuitable for generating secure random numbers.\n\nIn the given code snippet, `randArray[i] = (float)rand() / (float)RAND_MAX`, the `rand()` function is used to generate a random number. This could lead to vulnerabilities if the generated number is used in a security-critical context, such as generating encryption keys, random identifiers, etc.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of `rand()`. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\nrandArray[i] = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "92501975-87a5-32fa-b281-0bc19e1e7d11"
                ]
              }
            },
            {
              "id": "eeca9e4c-307e-317a-8012-dbfa7e93958a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of functions that generate random numbers which are not suitable for security-critical operations. The `rand()` function, for example, is a weak random number generator because it is predictable and can be easily reproduced, making it unsuitable for generating secure random numbers.\n\nIn the given code snippet, `randArray[i] = (float)rand() / (float)RAND_MAX`, the `rand()` function is used to generate a random number. This could lead to vulnerabilities if the generated number is used in a security-critical context, such as generating encryption keys, random identifiers, etc.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong cryptographic random number generator instead of `rand()`. In C++, you can use functions provided by libraries like `<random>` which provides a variety of random number generators that are more secure and less predictable.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code snippet:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 1);\n\nrandArray[i] = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. `std::uniform_real_distribution` produces random floating-point numbers in the range [0, 1).\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "eeca9e4c-307e-317a-8012-dbfa7e93958a"
                ]
              }
            },
            {
              "id": "164384e9-6aba-3b59-b74f-453d7b52289f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "164384e9-6aba-3b59-b74f-453d7b52289f"
                ]
              }
            },
            {
              "id": "859cb934-6c4b-398d-b849-32bcfca70035",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4d63bee9-96b8-3d59-9107-bfbc826e7a34",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "18531015-7d71-3110-b3c1-e3c001547eda",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "cf583bbf-8154-3491-8618-711bbe38e462",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bc428d83-ac22-3b03-8934-d96f0111bdec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "bc428d83-ac22-3b03-8934-d96f0111bdec"
                ]
              }
            },
            {
              "id": "b5d4ab47-3050-313e-a7bc-08ca7aeb8dbd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "b5d4ab47-3050-313e-a7bc-08ca7aeb8dbd"
                ]
              }
            },
            {
              "id": "adb2987d-f07d-3f00-8e8c-97dc9fd29014",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The destination and source buffers are both members of the same object, which increases the likelihood that they may overlap, especially if they are aliases or point to the same memory. Additionally, there are no explicit checks to ensure that the source and destination are non-null, which could also lead to undefined behavior if either pointer is null. The absence of guards or evidence that the memory regions are distinct further supports the risk. This type of issue can result in unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, ensure that the source and destination buffers do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (verificationInput != nullptr && pixelData != nullptr) {\n    memmove(verificationInput, pixelData, width * height * sizeof(uchar4));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5dc1c22a-ef0a-344c-b8cd-149b7ed2e9af",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The source and destination expressions both originate from the same object (indicated by 'this'), which increases the likelihood of overlap. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the operation. This can lead to unpredictable behavior or program crashes. The absence of capacity information for the destination buffer and the lack of a guard for the copy size further increase the risk. Developers should ensure that the source and destination buffers do not overlap when using memory copy functions like memcpy, as overlapping regions can result in undefined behavior.\n\n## In Context Remediation\nTo prevent undefined behavior caused by overlapping memory regions, ensure that the source and destination buffers do not overlap before calling the memory copy function. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (pixelData != nullptr && outputImageData != nullptr) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(pixelData, outputImageData, width * height * sizeof(uchar4));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "cdac9135-01ed-3449-a97e-0d84db7b8859",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if the filename is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the filename and ensure it is not controlled by an untrusted user or process. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ofstream fd;\nfd.open(filename, std::ios::out | std::ios::binary);\nif (!fd.is_open()) {\n    // Handle error\n}\n```\n\nIn this fix, we use the C++ `std::ofstream` class from the `<fstream>` library, which is a safer alternative to `fopen`. We also check if the file was successfully opened before proceeding.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<cstdio>` for `fopen`\n\nThe fixed code requires the following library:\n\n- `<fstream>` for `std::ofstream`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "896c7706-9273-360b-9ef9-83f34c1d4927",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In this case, the `fopen` function is used, which can lead to vulnerabilities if the filename is not properly validated or controlled, potentially leading to arbitrary file read access.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and sanitization of inputs. In the case of `fopen`, it is important to validate and control the filename that is being opened. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ifstream file;\nfile.open(filename, std::ios::binary);\n\nif (!file) {\n    // Handle error\n}\n```\n\nIn this example, the C++ `ifstream` class is used instead of the C `fopen` function. This provides a safer and more idiomatic way to handle files in C++. \n\n## Library Dependencies\n\nThe code example requires the following library:\n\n* `<fstream>`\n\n## References\n\n* [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n* [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "657f24db-243f-3b47-948b-f210acfece66",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the function `fopen` is used, which can lead to vulnerabilities if the filename is not properly validated or controlled.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or ensure proper validation and error handling. In the case of `fopen`, it is important to validate the filename and ensure it is not controlled by an untrusted user or process. \n\n## Source Code Fix Recommendation\n\n```cpp\n#include <fstream>\n\nstd::ofstream fd;\nfd.open(filename, std::ios::out | std::ios::binary);\nif (!fd.is_open()) {\n    // Handle error\n}\n```\n\nIn this fix, we use the C++ `std::ofstream` class from the `<fstream>` library, which is a safer alternative to `fopen`. We also check if the file was successfully opened before proceeding.\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<cstdio>` for `fopen`\n\nThe fixed code requires the following library:\n\n- `<fstream>` for `std::ofstream`\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a46067e5-a312-33dc-9e85-1e730c1ef069",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The destination and source pointers are both members of the same object, which increases the likelihood that they may refer to overlapping memory. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the operation. This combination of factors means that the code may trigger undefined behavior if the source and destination buffers overlap or if either pointer is null. Such issues can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use a memory-safe function or add explicit checks. Also, verify that both pointers are non-null before the operation to prevent null pointer dereference.\n\n```cpp\nif (inputImageData != nullptr && pixelData != nullptr &&\n    (inputImageData + (width * height)) <= pixelData ||\n    (pixelData + (width * height)) <= inputImageData) {\n    memcpy(inputImageData, pixelData, width * height * sizeof(uchar4));\n} else {\n    // Handle error: overlapping or null pointers\n}\n```\n\nAlternatively, if overlap is possible and intentional, use `memmove` instead of `memcpy`, as `memmove` is defined for overlapping regions:\n\n```cpp\nif (inputImageData != nullptr && pixelData != nullptr) {\n    memmove(inputImageData, pixelData, width * height * sizeof(uchar4));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "e1bc17f0-7430-3b94-9a1d-170d70e54fdb",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The code uses a memory copy function to transfer data from one buffer to another, but dataflow analysis suggests that the source and destination buffers may overlap. This can lead to unpredictable results or program crashes, as the standard memory copy function does not guarantee correct behavior when source and destination overlap. The source and destination are both confirmed to be non-null before the call, which reduces the risk of null pointer dereference, but does not mitigate the overlap risk. The source kind is not a string literal or C string, so the overlap risk remains relevant. No explicit guard or check is present to ensure that the buffers do not overlap.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping buffers, use a memory move function that is designed to handle overlapping regions safely. Replace the memory copy function with a memory move function, keeping the same arguments. This ensures that the operation is safe even if the source and destination buffers overlap.\n\n```cpp\nmemmove(colors_, rhs.colors_, numColors_ * sizeof(ColorPalette));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "7cce925e-12f3-3de9-9bb2-f2046cf35b91",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The code uses a memory copy function to copy data from one buffer to another, and dataflow analysis suggests that the source and destination buffers may overlap. If the source and destination regions overlap, the behavior of the memory copy function is undefined, which can lead to data corruption or unpredictable program behavior. There are no explicit checks or guarantees in the code to prevent this overlap. Both the source and destination are confirmed to be non-null before the call, so null pointer dereference is not a concern here. However, the potential for overlapping memory regions remains a significant risk.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory move function that is designed to handle overlapping regions safely. Replace the memory copy function with a memory move function, which guarantees correct behavior even if the source and destination overlap.\n\n```cpp\nmemmove(pixels_, rhs.pixels_, width * height * sizeof(uchar4));\n```\n\nThis change ensures that the copy operation is safe regardless of whether the source and destination buffers overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "3274618e-baf0-370b-b251-6c4d6a5c4d4c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits without returning (e.g., via `longjmp()` or `exit()`).\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use safer alternatives such as `std::vector` or `std::array` for stack-based arrays, and `new` or `std::unique_ptr` for heap-based arrays. These alternatives automatically manage memory and prevent stack overflow and undefined behavior.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` call with a `std::vector`:\n\n```cpp\nstd::vector<::size_t> lengths(n);\n```\n\nThis code does not have any additional library dependencies.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1dbf07a0-eb8b-3e8f-b359-4c635747bba0",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. These functions are often prohibited because they can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the `alloca()` function is used, which is considered unsafe.\n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `realloc()`. These functions are safer because they do not risk stack overflow and do not lead to undefined behavior if the function that called them exits via `longjmp()`.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`. Remember to check if `malloc()` returns `NULL`, which indicates that the memory allocation failed. Also, remember to free the memory when you're done with it to avoid memory leaks.\n\n```cpp\nstrings = (const char**) malloc(n * sizeof(const char*));\nif (strings == NULL) {\n    // Handle error\n}\n// Use strings\nfree(strings);\n```\n\n## Library Dependencies\n\nThe code example requires the `stdlib.h` library for the `malloc()` and `free()` functions.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "df07884d-93a7-34c6-9467-8a83c66d2caf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits without returning (e.g., via `longjmp()` or `exit()`).\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use safer alternatives such as `std::vector` or `std::array` for stack-based arrays, and `new` or `std::unique_ptr` for heap-based arrays. These alternatives automatically manage memory and prevent stack overflow and undefined behavior.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` call with a `std::vector`:\n\n```cpp\nstd::vector<::size_t> lengths(n);\n```\n\nThis code does not have any additional library dependencies.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8234c028-c19b-32ba-94a7-7a6977ef0379",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits without returning (e.g., via `longjmp()` or `exit()`).\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `realloc()`. These functions return a pointer to the allocated memory, which must be manually freed with `free()` when it is no longer needed. This gives the programmer more control over the memory and helps prevent stack overflow.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`. Here is the fixed code:\n\n```cpp\ncl_mem* mem = (cl_mem*) malloc(mem_objects->size() * sizeof(cl_mem));\nif (mem == NULL) {\n    // Handle error\n}\n```\n\nRemember to free the allocated memory with `free()` when it is no longer needed.\n\n## Library Dependencies\n\nThe code example requires the OpenCL library to execute properly.\n\n## References\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)\n\nPlease note that the links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b30307c-dec9-333a-a9e9-9fa0af3def11",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure or unsafe C functions in C++ code. In this case, the function `alloca()` is used, which is considered unsafe. The `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` is exited without returning (e.g., via `longjmp()` or `throw`).\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use safer alternatives such as `malloc()`, `calloc()`, or `new` for dynamic memory allocation. These functions allocate memory on the heap, which is safer and more flexible than stack allocation. However, remember to manually free the memory with `free()` or `delete` when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `new`:\n\n```cpp\nids = new cl_platform_id[n];\n```\n\nRemember to delete the memory when it is no longer needed:\n\n```cpp\ndelete[] ids;\n```\n\n## Library Dependencies\n\nThe code example requires the OpenCL library to execute properly.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "02b7fac2-a129-32aa-acd6-7ad54a4b1c25",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, memory leaks, or other types of undefined behavior. In this case, the function `alloca()` is being used, which is generally considered unsafe. This function dynamically allocates memory on the stack, which can lead to stack overflow if the requested size is too large. \n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `new` in C++. These functions are safer because they return a null pointer if the requested memory cannot be allocated, whereas `alloca()` causes undefined behavior.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `new`:\n\n```cpp\nvalue = new Kernel[numKernels];\n```\n\nRemember to deallocate the memory when it's no longer needed:\n\n```cpp\ndelete[] value;\n```\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f9f319d8-4139-35d7-b6b2-dbf880c86975",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that occurs when a program uses a dangerous C function that can introduce a security risk. In this case, the function `alloca()` is used, which is a function that allocates memory on the stack. This can lead to several issues:\n\n- Stack overflow: If `alloca()` is called with a large size, it can cause a stack overflow, which can lead to a crash or even code execution.\n- Unchecked return value: `alloca()` does not return a null pointer when it fails, but it may instead cause a segmentation fault or other undefined behavior.\n- Portability: `alloca()` is not defined in the ISO C standard, and its use is discouraged.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to replace `alloca()` with a safer function. In C++, `new` can be used to allocate memory on the heap instead of the stack. This memory should be freed with `delete` when it is no longer needed.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `new`:\n\n```cpp\nimages = new const unsigned char*[n];\n```\n\nAnd don't forget to free the memory when it is no longer needed:\n\n```cpp\ndelete[] images;\n```\n\n## Library Dependencies\n\nThe code example does not appear to have any library dependencies.\n\n## OWASP and CWE Links\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f434acd3-f4cf-30e0-b397-5a0557706911",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause serious security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function in question is `alloca()`. \n\nThe `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size argument is too large, as the amount of space available on the stack is much less than that available on the heap. \n\n## Mitigation Advice\n\nAvoid using `alloca()` function. Instead, use functions like `malloc()`, `calloc()`, or `realloc()` which allocate memory on the heap and do not automatically free it when the function returns. These functions are safer as they return a null pointer if the allocation fails, whereas `alloca()` does not have any mechanism to indicate failure.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how you can do it:\n\n```cpp\n// Old code\n// alloca(numEntries * sizeof(ImageFormat))\n\n// New code\nImageFormat* imageFormat = (ImageFormat*) malloc(numEntries * sizeof(ImageFormat));\nif (imageFormat == NULL) {\n    // Handle error\n}\n```\n\nRemember to free the allocated memory when you're done using it:\n\n```cpp\nfree(imageFormat);\n```\n\n## Library Dependencies\n\nThe `alloca()` function is declared in the `alloca.h` header file (or `stdlib.h` in some systems). The `malloc()` and `free()` functions are declared in the `stdlib.h` header file.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-770: Allocation of Resources Without Limits or Throttling](https://cwe.mitre.org/data/definitions/770.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "bdc43e77-c7f9-30c9-8a14-76772732574f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, memory leaks, or other types of undefined behavior. In this case, the `alloca` function is used, which is generally considered unsafe. The `alloca` function allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. However, because the size of the stack is limited, `alloca` can easily cause a stack overflow if the requested size is too large.\n\n## Mitigation Advice\n\nAvoid using `alloca` and other unsafe C functions. Instead, use safer alternatives provided by the C++ standard library. In this case, you can use `std::vector` to dynamically allocate an array of `cl_device_id` objects. `std::vector` automatically manages the memory for you, so you don't have to worry about freeing it manually. Also, `std::vector` throws an exception if the requested size is too large, which prevents stack overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` call with a `std::vector`:\n\n```cpp\n#include <vector>\n\nstd::vector<cl_device_id> ids(n);\n```\n\n## Library Dependencies\n\nThe code example requires the OpenCL library to define the `cl_device_id` type.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "5f6b5954-6eaf-37fd-b8fa-7c7368243371",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, memory leaks, or other types of undefined behavior. In this case, the `alloca` function is used, which is generally considered unsafe. The `alloca` function allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. However, because the size of the stack is limited, `alloca` can easily cause a stack overflow if the requested size is too large.\n\n## Mitigation Advice\n\nAvoid using `alloca` and other unsafe C functions. Instead, use safer alternatives provided by the C++ standard library. In this case, you can use `std::vector` to dynamically allocate an array of `cl_device_id` objects. `std::vector` automatically manages the memory for you, so you don't have to worry about freeing it manually. Also, `std::vector` throws an exception if the requested size is too large, which prevents stack overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` call with a `std::vector`:\n\n```cpp\n#include <vector>\n\nstd::vector<cl_device_id> ids(n);\n```\n\n## Library Dependencies\n\nThe code example requires the OpenCL library to define the `cl_device_id` type.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "014b0329-2da0-3822-b493-1d22b2ac370f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, memory leaks, or other types of undefined behavior. In this case, the `alloca` function is used, which is generally considered unsafe. The `alloca` function allocates memory on the stack, which is automatically freed when the function that called `alloca` returns. However, because the size of the stack is limited, `alloca` can easily cause a stack overflow if the requested size is too large.\n\n## Mitigation Advice\n\nAvoid using `alloca` and other unsafe C functions. Instead, use safer alternatives provided by the C++ standard library. In this case, you can use `std::vector` to dynamically allocate an array of `cl_device_id` objects. `std::vector` automatically manages the memory for you, so you don't have to worry about freeing it manually. Also, `std::vector` throws an exception if the requested size is too large, which prevents stack overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca` call with a `std::vector`:\n\n```cpp\n#include <vector>\n\nstd::vector<cl_device_id> ids(n);\n```\n\n## Library Dependencies\n\nThe code example requires the OpenCL library to define the `cl_device_id` type.\n\n## OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "aef116ff-fdbf-39dd-95cb-308a3fabef66",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The code copies data from one buffer to another using a function that is not safe if the source and destination regions overlap. Dataflow analysis suggests that the source and destination may refer to overlapping memory, which can lead to unpredictable results or program crashes. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source may also be null, which further increases the risk. The destination is likely a local or field array, reducing the risk of it being null, but the overlap concern remains the primary issue.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a function that is safe for overlapping regions. Replace the memory copy function with one that handles overlap, such as `memmove`, which is designed for this purpose. This ensures that even if the source and destination buffers overlap, the operation will complete safely and predictably.\n\n```cpp\nmemmove(&data_[0], &rhs.data_[0], size() * sizeof(T));\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "b6e1db2c-59f7-33e8-9a93-80ad5ae93d53",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Prohibited C Function Identified\" is a vulnerability that occurs when a program uses a dangerous C function that can introduce a security risk. In this case, the function `alloca()` is used, which is a function that dynamically allocates memory on the stack. This can lead to several issues such as buffer overflows, stack overflows, and other memory corruption issues, which can be exploited to execute arbitrary code, cause a denial of service, or gain unauthorized access to data.\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions that allocate memory on the heap, such as `malloc()`, `calloc()`, or `realloc()`. These functions are safer because they do not risk a stack overflow and the allocated memory is initialized to zero, which can prevent some types of memory corruption vulnerabilities.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`. Also, remember to check if `malloc()` returns `NULL`, which indicates that the memory allocation failed. If `malloc()` fails, handle the error appropriately, for example by cleaning up and terminating the program. Finally, remember to free the allocated memory with `free()` when it is no longer needed.\n\n```cpp\nchar* value = (char*) malloc(required);\nif (value == NULL) {\n    // handle error\n}\n// use value\nfree(value);\n```\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "d48526f7-13ee-3115-89bb-292ac1c11a74",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of insecure C functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. In this case, the function `alloca()` is used, which is a potential security risk. The `alloca()` function dynamically allocates memory on the stack, which is automatically freed when the function that called `alloca()` returns. This can lead to stack overflow if the size of the allocation is too large, and it can also lead to undefined behavior if the function that called `alloca()` exits via `longjmp()`.\n\n## Mitigation Advice\n\nAvoid using `alloca()`. Instead, use functions like `malloc()`, `calloc()`, or `realloc()`, which allocate memory on the heap rather than the stack. These functions do not have the same risks as `alloca()`. However, remember to free the memory allocated with these functions when it is no longer needed to prevent memory leaks.\n\n## Source Code Fix Recommendation\n\nReplace the `alloca()` function with `malloc()`, `calloc()`, or `realloc()`. Here is an example of how to do it:\n\n```cpp\n// Old code\n// T* value = (T*) alloca(required);\n\n// New code\nT* value = (T*) malloc(required);\nif (value == NULL) {\n    // Handle error\n}\n// Remember to free the memory when it is no longer needed\nfree(value);\n```\n\n## Library Dependencies\n\nThe `malloc()` and `free()` functions are part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "4bf084ad-84c3-3627-b5f3-f927b7bb5a8a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The code copies data from one buffer to another using a memory copy function, but dataflow analysis suggests that the source and destination may overlap, which is not allowed for this function and can result in unpredictable behavior. Additionally, there is no evidence of explicit checks or guards to prevent this overlap, and the source may also be null, which further increases the risk. The destination buffer appears to be a local or field array, reducing the risk of it being null, but the overlap risk remains the primary concern. Developers should ensure that the source and destination buffers do not overlap when using this function, or use a function that safely handles overlapping regions if overlap is possible.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is designed to handle overlap, such as `memmove`, instead of `memcpy`. This ensures that the copy operation is safe even if the source and destination buffers overlap.\n\n```cpp\n// Replace memcpy with memmove to safely handle overlapping regions\nmemmove(&data_[0], &vec.data_[0], size() * sizeof(T));\n```\n\nAdditionally, ensure that both source and destination pointers are valid and not null before performing the copy operation. If you know for certain that the regions never overlap, document this assumption clearly in the code to aid future maintainers.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "78389e7f-e4ab-3180-be6c-dd501a78f4ce",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap. The analysis detected that the destination and source may refer to overlapping memory regions due to data flow between them. This can lead to undefined behavior according to the C standard, as memcpy is not safe for overlapping memory regions. There are no explicit checks or guards in the code to prevent this overlap, and the types involved are pointers, making it difficult to guarantee non-overlapping regions without further context. Both the source and destination are confirmed to be non-null, so null pointer dereference is not a concern here. However, the risk of undefined behavior due to overlapping memory remains significant and should be addressed.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination memory regions may overlap, replace the memory copy operation with a function that is safe for overlapping regions, such as `memmove`. `memmove` is specifically designed to handle overlapping memory areas safely.\n\n```cpp\nmemmove(str_, rhs.str_, (size_ + 1) * sizeof(char));\n```\n\nThis change ensures that even if `str_` and `rhs.str_` overlap, the copy will be performed correctly without causing undefined behavior.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "a341c91e-334a-3dc1-8cd8-dd2f04ff1c67",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can result in crashes, incorrect behavior, or potential execution of malicious code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen` on strings that may not be null-terminated. Instead, consider using safer alternatives that take the maximum length of the string as an argument, such as `strnlen`.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen` function with `strnlen` and provide the maximum length of the string as an argument. This will prevent the function from reading beyond the intended memory area.\n\n```cpp\nsize_t max_length = 100; // replace with actual maximum length\nsize_ = ::strnlen(str, max_length);\n```\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "7e17b001-d0f5-379d-93be-dd4b8fc956b8",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the code uses a memory copy operation where the source and destination buffers may overlap, which can result in undefined behavior. The analysis detected that the destination and source may refer to overlapping memory regions due to data flow between them. There is no evidence of a guard or check to prevent this overlap. Additionally, the destination pointer may be null, which could also lead to undefined behavior if not properly checked. The source is confirmed to be non-null before the call, but the risk of overlap remains. This type of issue can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping memory regions safely. Also, ensure that the destination pointer is not null before performing the operation.\n\n```cpp\nif (this->str_ != nullptr && str != nullptr) {\n    memmove(this->str_, str, size_ * sizeof(char));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5bce0b92-f0db-3ed4-8840-c85dcbe9ed0e",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination buffers. Both the source and destination are member pointers of the same object, which increases the likelihood that they may refer to overlapping memory regions. Additionally, there are no explicit checks in the code to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the memory copy operation. This combination of factors means that the code may invoke undefined behavior if the source and destination buffers overlap or if either pointer is null. Such issues can lead to unpredictable program behavior, data corruption, or crashes.\n\n## In Context Remediation\nBefore performing the memory copy, ensure that the source and destination buffers do not overlap and are both non-null. If overlap is possible, use a safer function or add explicit checks. For example:\n\n```cpp\nif (verificationPathMatrix != nullptr && pathMatrix != nullptr &&\n    (verificationPathMatrix + numNodes * numNodes <= pathMatrix ||\n     pathMatrix + numNodes * numNodes <= verificationPathMatrix)) {\n    memcpy(verificationPathMatrix, pathMatrix, numNodes * numNodes * sizeof(int));\n} else {\n    // Handle error: overlapping or null pointers\n}\n```\nThis code checks for null pointers and ensures that the memory regions do not overlap before calling memcpy. If overlap is possible, consider using `memmove`, which is safe for overlapping regions, but only if overlap is truly required by the logic.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "419a91f1-90d3-3f21-9feb-b2a8f7e36cb8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program's operations, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nThe specific vulnerability sink in the provided code is the use of `rand()` function, which is a weak random number generator. The `rand()` function generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, the `<random>` library provides several such generators. These generators produce numbers that are more random and less predictable, making them suitable for cryptographic operations.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a strong random number generator. Here is a fixed version of the provided code:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(rangeMin, rangeMax);\n\narrayPtr[index] = dis(gen);\n```\n\n## Library Dependencies\n\nThe fixed code requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "419a91f1-90d3-3f21-9feb-b2a8f7e36cb8"
                ]
              }
            },
            {
              "id": "5daf7c9b-f39e-30bd-920e-bb55df50e191",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The destination and source pointers are both members of the same object (indicated by 'this'), which increases the likelihood that they may refer to overlapping memory. Additionally, there are no explicit checks in the code to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the operation. This combination of factors means that the code may invoke undefined behavior if the memory regions overlap or if either pointer is null, which can lead to unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `memmove`, instead of `memcpy`. `memmove` correctly handles overlapping source and destination regions, ensuring data is copied safely.\n\n```cpp\nmemmove(verificationPathDistanceMatrix, pathDistanceMatrix, numNodes * numNodes * sizeof(int));\n```\n\nAdditionally, consider adding explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (verificationPathDistanceMatrix != nullptr && pathDistanceMatrix != nullptr) {\n    memmove(verificationPathDistanceMatrix, pathDistanceMatrix, numNodes * numNodes * sizeof(int));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "94f5a852-66ef-3065-9b7f-b4b87b1e9633",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program's operations, leading to a variety of security issues such as unauthorized access, data leakage, and other forms of attacks.\n\nThe specific vulnerability sink in the provided code is the use of `rand()` function, which is a weak random number generator. The `rand()` function generates pseudo-random numbers that are not suitable for cryptographic operations.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, the `<random>` library provides several such generators. These generators produce numbers that are more random and less predictable, making them suitable for cryptographic operations.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a strong random number generator. Here is a fixed version of the provided code:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(rangeMin, rangeMax);\n\narrayPtr[index] = dis(gen);\n```\n\n## Library Dependencies\n\nThe fixed code requires the following library dependencies:\n\n- `<random>`\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "94f5a852-66ef-3065-9b7f-b4b87b1e9633"
                ]
              }
            },
            {
              "id": "7be40671-7dc9-37fb-a13d-0d3e69eafd88",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination buffers in the memory copy operation. The source and destination are both members of the same object (indicated by 'this'), which increases the likelihood of overlap if not carefully managed. Additionally, there are no explicit checks to ensure that the source and destination pointers are non-null, which could lead to null pointer dereference. The count argument is not directly tied to the known capacity of the destination buffer, and there are no guards or evidence that the length is safe. The source kind is not a string literal or constant, so the risk of overlap is not reduced. All these factors contribute to a high confidence in the presence of a real issue.\n\n## In Context Remediation\nTo prevent undefined behavior from overlapping memory regions, ensure that the source and destination buffers do not overlap before calling the memory copy function. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null pointer checks for both the source and destination pointers before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (verificationInput != nullptr && input != nullptr && verificationInput != input) {\n    memcpy(verificationInput, input, length * sizeof(unsigned int));\n}\n```\n\nIf overlap between `verificationInput` and `input` is possible, replace `memcpy` with `memmove`:\n\n```cpp\nif (verificationInput != nullptr && input != nullptr) {\n    memmove(verificationInput, input, length * sizeof(unsigned int));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "65be0994-4c81-3925-b816-da30fbd5e3bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of certain C standard library functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other issues that can lead to arbitrary code execution or denial of service. In this case, the function `rewind()` is flagged as a potential vulnerability sink.\n\nThe `rewind()` function sets the file position to the beginning of the file for the stream pointed to by `input`. It also clears the error and end-of-file indicators for the stream. If the file is unable to be rewound (for example, if the stream is not open), this could potentially lead to unexpected behavior.\n\n## Mitigation Advice\n\nAvoid using the `rewind()` function if possible. Instead, consider using `fseek()`, `fsetpos()`, or `fgetpos()`, which provide more control over file positioning and error handling.\n\n## Source Code Fix Recommendation\n\nReplace the `rewind(input)` function with `fseek(input, 0, SEEK_SET)`. This will also set the file position to the beginning of the file, but it will return a non-zero value if the operation fails, allowing for error handling.\n\n```cpp\nif (fseek(input, 0, SEEK_SET) != 0) {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `rewind()` function is part of the C standard library, so the code example requires the `stdio.h` header file.\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c0122051-0d0f-35ef-9103-d11af2b866c6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. The `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm and can produce predictable results.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, the `<random>` library provides non-deterministic random number generators such as `std::random_device`, which should be used instead of `rand()`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with `std::random_device`. Here is how you can do it:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> distr(0, binSize-1);\n\ndata[i] = distr(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "c0122051-0d0f-35ef-9103-d11af2b866c6"
                ]
              }
            },
            {
              "id": "ca1f7154-4a7c-34c6-b012-bda15b8e7f7b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen` on strings that come from untrusted sources without validation. Consider using safer alternatives such as `strnlen`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlength = strlen(input);\n```\n\nYou could use:\n\n```cpp\nstrlength = strnlen(input, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string. This will prevent `strnlen` from reading beyond the specified limit, even if it doesn't encounter a null character.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional libraries are needed for the code to execute properly.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "077cd707-86e3-39a9-b6b1-8a6e059c88ce",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the null-terminating character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow or other undefined behavior.\n\nIn the provided code snippet `!strlen(next)`, the vulnerability arises if `next` is not a null-terminated string. This could lead to unexpected behavior or even a security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string after it has been modified.\n\n## Source Code Fix Recommendation\n\n```cpp\nif (next != NULL && next[0] != '\\0') {\n    // Your code here\n}\n```\n\nIn this fixed code, we first check if `next` is not NULL and then check if the first character of `next` is not the null character. This ensures that `next` is a null-terminated string before we use it.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed to use it.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "9adedea7-29b3-3dec-895d-3ed4efcdb7fc",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the null-terminating character. If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null byte, potentially leading to a buffer overflow or other undefined behavior.\n\nIn the provided code snippet `!strlen(next)`, the vulnerability arises if `next` is not a null-terminated string. This could lead to unexpected behavior or even a security vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. This can be done by initializing strings with a null character at the end, or by manually adding a null character to the end of the string after it has been modified.\n\n## Source Code Fix Recommendation\n\n```cpp\nif (next != NULL && next[0] != '\\0') {\n    // Your code here\n}\n```\n\nIn this fixed code, we first check if `next` is not NULL and then check if the first character of `next` is not the null character. This ensures that `next` is a null-terminated string before we use it.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed to use it.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "95c7693f-3d4f-3c5d-896e-6f5cf09bb856",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and can be exploited by an attacker. The `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm and can produce predictable results.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, the `<random>` library provides non-deterministic random number generators such as `std::random_device`, which should be used instead of `rand()`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with `std::random_device`. Here is how you can do it:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> distr(0, binSize-1);\n\ndata[i] = distr(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "95c7693f-3d4f-3c5d-896e-6f5cf09bb856"
                ]
              }
            },
            {
              "id": "ccf189b0-fbfa-38b5-926b-7746cf6da3b9",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination buffers in the memory copy operation. The destination and source expressions both originate from the same object instance, which increases the likelihood of overlap. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the operation. The use of a pointer type for the destination, with no known capacity, further increases the risk. These factors together indicate a real risk of undefined behavior, which can lead to unpredictable program behavior or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that neither the source nor the destination pointer is null before performing the copy operation. For example:\n\n```cpp\nif (verificationInput != nullptr && input != nullptr) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(verificationInput, input, inputSizeBytes);\n}\n```\n\nIf you are certain that the regions never overlap, document this assumption clearly in the code and consider adding runtime assertions to enforce it during development:\n\n```cpp\nassert(verificationInput != input);\nmemcpy(verificationInput, input, inputSizeBytes);\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "01fbc6ce-91fd-3a34-aff8-9db0aa0a8ca1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to a vulnerability if the string is not null-terminated. This is because `strlen` counts characters until it reaches a null character. If the string is not null-terminated, `strlen` will continue reading memory beyond the intended boundary, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character (`'\\0'`) at the end, or by using functions that automatically null-terminate strings, such as `strncpy`.\n\nAdditionally, consider using safer alternatives to `strlen`, such as `strnlen`, which takes a maximum length parameter and will not read beyond this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf you have the following code:\n\n```cpp\nchar str[100];\n// ... some code that populates str ...\nl = strlen(str);\n```\n\nYou can fix it by ensuring `str` is null-terminated:\n\n```cpp\nchar str[100] = {'\\0'};\n// ... some code that populates str ...\nl = strlen(str);\n```\n\nOr by using `strnlen`:\n\n```cpp\nchar str[100];\n// ... some code that populates str ...\nl = strnlen(str, sizeof(str));\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\nThe `strnlen` function is part of the GNU C Library, so you need to include the `string.h` header:\n\n```cpp\n#include <string.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "3131d197-9532-3d3d-8fd9-2b488956eec0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program, leading to security breaches.\n\nThe `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm. This means that it will produce the same sequence of numbers each time the program is run with the same seed value. This predictability can be exploited by an attacker to predict the sequence of random numbers generated by the program.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use functions from the `<random>` library, such as `std::random_device` and `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a cryptographic random number generator. Here is an example of how to do this:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 10);\n\nfor (int i = 0; i < 10; i++) {\n    mHostBdata[i] = dis(gen);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "3131d197-9532-3d3d-8fd9-2b488956eec0"
                ]
              }
            },
            {
              "id": "2221f151-ccc5-3a7b-928f-11c6f003d29e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program, leading to security breaches.\n\nThe `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm. This means that it will produce the same sequence of numbers each time the program is run with the same seed value. This predictability can be exploited by an attacker to predict the sequence of random numbers generated by the program.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use functions from the `<random>` library, such as `std::random_device` and `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a cryptographic random number generator. Here is an example of how to do this:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 10);\n\nfor (int i = 0; i < 10; i++) {\n    mHostBdata[i] = dis(gen);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "2221f151-ccc5-3a7b-928f-11c6f003d29e"
                ]
              }
            },
            {
              "id": "23aa7c5c-1175-36cb-ab06-e2303650ff62",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program, leading to potential security risks.\n\nThe `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm. This means that given the same seed, it will produce the same sequence of numbers every time. This makes it unsuitable for generating random numbers in a security context, where unpredictability is crucial.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use functions provided by the `<random>` library, such as `std::random_device` or `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a cryptographic random number generator. Here is an example of how to do this:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 10);\n\nmHostAdata[i] = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "23aa7c5c-1175-36cb-ab06-e2303650ff62"
                ]
              }
            },
            {
              "id": "99338c2c-5e1d-3667-998e-efbe09e69655",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by attackers to predict the outcome of the program, leading to potential security risks.\n\nThe `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm. This means that given the same seed, it will produce the same sequence of numbers every time. This makes it unsuitable for generating random numbers in a security context, where unpredictability is crucial.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use functions provided by the `<random>` library, such as `std::random_device` or `std::mt19937`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with a cryptographic random number generator. Here is an example of how to do this:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(0, 10);\n\nmHostAdata[i] = dis(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "99338c2c-5e1d-3667-998e-efbe09e69655"
                ]
              }
            },
            {
              "id": "d32e157e-9030-3aab-a960-10e50e392f5b",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in a memory copy operation. The destination and source may refer to the same or overlapping memory, which is not allowed for the standard memory copy function and can result in unpredictable program behavior. The risk is further supported by the dataflow analysis indicating a possible overlap, and there are no explicit checks or guards in the code to prevent this scenario. Additionally, the destination pointer may be null, which could also lead to a crash or undefined behavior. The source is not a string literal or constant, so the overlap risk is not mitigated by the nature of the source.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination buffers may overlap, use a memory move function that safely handles overlapping regions. Replace the memory copy function with a memory move function, which is designed to handle overlapping memory areas safely. For example:\n\n```cpp\nmemmove(str_, str, (size_ + 1) * sizeof(char));\n```\n\nAdditionally, ensure that the destination pointer is not null before performing the operation to avoid potential crashes:\n\n```cpp\nif (str_ != nullptr && str != nullptr) {\n    memmove(str_, str, (size_ + 1) * sizeof(char));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "5b82f7ec-b5b4-341b-894a-5fcef5251c0a",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because the analysis detected a possible risk of undefined behavior due to overlapping memory regions in a memory copy operation. The destination and source pointers are both members of the same object, which increases the likelihood that they may refer to overlapping memory. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the operation. This combination of factors means that the code may trigger undefined behavior if the source and destination buffers overlap or if either pointer is null. Such issues can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation 0\nTo prevent undefined behavior when copying memory between potentially overlapping regions, ensure that the source and destination buffers do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (inData != nullptr && dPartialOutData != nullptr) {\n    memmove(inData, dPartialOutData, (one << levels) * sizeof(float));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n## In Context Remediation 1\nIf you are certain that the source and destination never overlap, document this assumption clearly and add runtime assertions to enforce it during development. This can help catch logic errors early and prevent undefined behavior in production.\n\n```cpp\n#include <cassert>\n\nassert(inData != dPartialOutData); // Ensure no overlap if this is a valid assumption\nif (inData != nullptr && dPartialOutData != nullptr) {\n    memcpy(inData, dPartialOutData, (one << levels) * sizeof(float));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "4b426ba1-bc5a-359f-80a9-3871186f95ff",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the code uses a memory copy operation where the source and destination regions may overlap. The analysis detected that the source and destination expressions are derived from the same base (likely the same array or buffer), but with different offsets. This can lead to undefined behavior if the memory regions overlap, as the standard memory copy function does not guarantee correct results in such cases. Additionally, there is no evidence of explicit checks or guards to prevent overlap, and the source pointer may be null, which could also cause a crash. The risk is further increased because the size of the copy is calculated dynamically and not directly tied to a known safe buffer size.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory regions that may overlap, use a memory move function that is designed to handle overlapping regions safely. Replace the memory copy function with a memory move function, which guarantees correct results even if the source and destination overlap.\n\n```cpp\nmemmove(dOutData + (one << curLevels), hOutData + (one << curLevels), (signalLength - (one << curLevels)) * sizeof(float));\n```\n\nThis change ensures that the operation is safe regardless of whether the source and destination regions overlap.\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "c7ca8ffe-3993-3d89-b8c5-03999cf64ac9",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis detected a possible undefined behavior risk due to overlapping memory regions between the source and destination buffers in the memory copy operation. The source and destination are both pointers, and dataflow analysis suggests that the destination may be assigned to the source, making overlap feasible. Additionally, there are no explicit checks to ensure that the source and destination are not null, which increases the risk of undefined behavior. No evidence was found that the length argument is derived from the destination's capacity, and there are no guards to prevent underflow or null pointer dereference. Therefore, this is a high-confidence issue that should be addressed to prevent potential memory corruption or crashes.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit checks to ensure that both the source and destination pointers are not null before performing the copy operation. For example:\n\n```cpp\nif (inData != nullptr && temp != nullptr) {\n    memmove(inData, temp, signalLength * sizeof(float));\n}\n```\n\nThis change ensures that the copy operation is safe even if the memory regions overlap, and it prevents null pointer dereference. For further guidance, refer to the following resources:\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "190058a1-2f82-34be-a2f1-580453a45bcf",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination buffers in a memory copy operation. The analysis indicates that both the source and destination are members of the same object (as shown by the 'same base identifier: this'), which increases the likelihood of accidental overlap. Additionally, there are no explicit checks to ensure that the source and destination pointers are non-null, further increasing the risk of undefined behavior. The destination buffer is a pointer type with no known capacity, and the count argument is not directly tied to the destination's size, which means there is no guarantee that the copy will be safe. No explicit guard or null checks are present, and the risk of undefined behavior due to overlapping memory regions is not mitigated.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, ensure that the source and destination buffers do not overlap. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping memory safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (hOutData != nullptr && dOutData != nullptr) {\n    // Use memmove instead of memcpy to safely handle possible overlap\n    memmove(hOutData, dOutData, curSignalLength * sizeof(float));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "627e95ee-e40d-3517-901e-e4465b2609ce",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination buffers in a memory copy operation. The analysis detected that the source and destination may refer to overlapping memory regions, which can cause undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to prevent this overlap, and the source pointer may also be null, increasing the risk. The destination is a pointer, and its capacity is not known, which further increases the uncertainty. These factors indicate a real risk of memory corruption or program crashes if the overlap occurs.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination buffers may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping memory regions.\n\n```cpp\nmemmove(temp, inData, signalLength * sizeof(float));\n```\n\nAdditionally, ensure that both `temp` and `inData` are not null before performing the operation:\n\n```cpp\nif (temp != nullptr && inData != nullptr) {\n    memmove(temp, inData, signalLength * sizeof(float));\n}\n```\n\n## References\n- [OWASP: Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "367972c5-6b50-3669-a424-8aad135482df",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis indicates that both the source and destination pointers are members of the same object (as shown by the 'same base identifier: this'), which increases the likelihood of accidental overlap. Additionally, there are no explicit checks to ensure that the source and destination do not overlap, and there are no guards to verify that either pointer is non-null before the operation. This combination of factors means that the code may invoke undefined behavior if the memory regions overlap or if either pointer is null. Such issues can lead to unpredictable program behavior, data corruption, or security vulnerabilities.\n\n## In Context Remediation\nTo prevent undefined behavior from overlapping memory regions, ensure that the source and destination buffers do not overlap before calling the memory copy function. If overlap is possible, use `memmove` instead of `memcpy`, as `memmove` is designed to handle overlapping regions safely. Additionally, add explicit null pointer checks for both the source and destination before performing the copy to avoid null pointer dereference.\n\n```cpp\nif (hOutData != nullptr && dOutData != nullptr) {\n    // If overlap is possible, use memmove instead of memcpy\n    memmove(hOutData, dOutData, (one << curLevels) * sizeof(float));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "2272aa5e-56ac-316b-9781-8a9ebbddffa9",
              "help": {
                "text": "",
                "markdown": "This finding is classified as 'Likely Vulnerable' because the result of malloc is used as the destination in a memcpy call immediately after allocation, without any check for a NULL return value. There is no zero guard or overflow guard present, and the first use is a memory operation that would cause undefined behavior if malloc fails and returns NULL. The presence of a cast does not mitigate the risk. The pointer is freed in the method, but this does not affect the risk of null dereference. These factors indicate a genuine risk of null pointer dereference after failed allocation.\n\n## In Context Remediation\nTo prevent a possible null pointer dereference after memory allocation, always check the result of malloc before using the allocated memory. For example, after:\n\n```c\nfloat *temp = (float *)malloc(signalLength * sizeof(float));\n```\nadd a null check before using `temp`:\n\n```c\nfloat *temp = (float *)malloc(signalLength * sizeof(float));\nif (temp == NULL) {\n    // Handle allocation failure, e.g., log error and return or clean up\n    fprintf(stderr, \"Memory allocation failed\\n\");\n    return -1;\n}\n```\nThis ensures that if malloc fails, the program does not attempt to use a null pointer, which would result in undefined behavior or a crash.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "1f718e8c-20e0-305d-9ade-3c6d4e4a08c4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and hence can be exploited by an attacker. The `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm and can produce predictable results.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, the `<random>` library provides non-deterministic random number generators such as `std::random_device`, which should be used instead of `rand()`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with `std::random_device` as shown below:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> distr(0, 9);\n\ninData[i] = (float)distr(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "1f718e8c-20e0-305d-9ade-3c6d4e4a08c4"
                ]
              }
            },
            {
              "id": "2984cf55-33e9-3a44-973a-cab8ca44ff8b",
              "help": {
                "text": "",
                "markdown": "This finding highlights a real risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The analysis detected that the destination and source may refer to overlapping memory, as indicated by the data flow from destination to source. In C and C++, using functions like memcpy with overlapping memory regions is undefined behavior and can lead to unpredictable results or security vulnerabilities. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap. The source pointer may also be null, as there is no prior check to guarantee it is valid. These factors confirm that this is a genuine issue that should be addressed to ensure program correctness and security.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory where the source and destination may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to handle overlapping regions safely. Replace the original call with:\n\n```cpp\nmemmove(tempOutData, hOutData, signalLength * sizeof(float));\n```\n\nAdditionally, ensure that both `tempOutData` and `hOutData` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (tempOutData != nullptr && hOutData != nullptr) {\n    memmove(tempOutData, hOutData, signalLength * sizeof(float));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "07c422da-33e9-3c7f-a959-eee8de50325e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators that can lead to predictable values and hence can be exploited by an attacker. The `rand()` function in C++ is a weak random number generator as it uses a deterministic algorithm and can produce predictable results.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use a strong cryptographic random number generator. In C++, the `<random>` library provides non-deterministic random number generators such as `std::random_device`, which should be used instead of `rand()`.\n\n## Source Code Fix Recommendation\n\nReplace the `rand()` function with `std::random_device` as shown below:\n\n```cpp\n#include <random>\n\n// ...\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> distr(0, 9);\n\ninData[i] = (float)distr(gen);\n```\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "07c422da-33e9-3c7f-a959-eee8de50325e"
                ]
              }
            },
            {
              "id": "1c585d4d-b907-3e06-a26e-ff1a84d90d64",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis has detected a possible risk of undefined behavior due to overlapping memory regions between the source and destination buffers in the memory copy operation. The dataflow analysis indicates that the destination buffer may overlap with the source buffer, which can cause undefined behavior when using functions like memcpy. Additionally, there is no evidence of a guard or check to ensure that the source and destination do not overlap, and the source pointer may also be null at this point, further increasing the risk. The destination buffer is a pointer, and its capacity is not known, which adds to the uncertainty. These factors together make this a high-confidence, actionable issue.\n\n## In Context Remediation\nTo prevent undefined behavior when the source and destination buffers may overlap, use `memmove` instead of `memcpy`. `memmove` is designed to safely handle overlapping memory regions. Replace the original call with:\n\n```cpp\nmemmove(tempOutData, inData, signalLength * sizeof(float));\n```\n\nAdditionally, ensure that both `tempOutData` and `inData` are not null before performing the operation to avoid null pointer dereference:\n\n```cpp\nif (tempOutData != nullptr && inData != nullptr) {\n    memmove(tempOutData, inData, signalLength * sizeof(float));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "545a8ea5-2ffa-31d1-951b-dc1d2a900e8a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, or integer overflows. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer alternatives to these functions, or to perform proper input validation before using them. For `atoi()`, it is recommended to use `strtol()` or `sscanf()` instead, as these functions provide error checking.\n\n## Source Code Fix Recommendation\n\nReplace the `atoi()` function with `strtol()` or `sscanf()`. Here is an example of how to use `strtol()`:\n\n```cpp\nchar *end;\nlong burnSec = strtol(optarg, &end, 10);\nif (end == optarg || *end != '\\0' || errno == ERANGE) {\n    // handle error\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `stdlib.h` for `strtol()`\n- `errno.h` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9a1aa80b-e015-3267-853c-d9009b1560a1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a8149971-b308-3c50-a36e-b37210f8df9b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "9eee11fa-02de-36dc-955f-1530c44f795f",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "8d4ed873-8b5b-30bb-8952-ede73f2f7d66",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "76b56097-18ea-3404-bd77-b698b5f8827f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "76b56097-18ea-3404-bd77-b698b5f8827f"
                ]
              }
            },
            {
              "id": "8bb2f17d-a424-3fde-b57c-4ca4309f03ab",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "8bb2f17d-a424-3fde-b57c-4ca4309f03ab"
                ]
              }
            },
            {
              "id": "baa2ea4e-6b48-3576-86bc-1b3d002e8ee1",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "3b804fcb-fcdb-344b-b888-b96885fbd87d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "29eeda33-9799-3a5a-a1b7-65ae8121184e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "f19b27c3-52ca-3b1a-9dd9-3afd6338cdb4",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "772ad978-0da6-3bad-85d8-f8a71ab89c6f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "772ad978-0da6-3bad-85d8-f8a71ab89c6f"
                ]
              }
            },
            {
              "id": "a31d7a23-afbe-3d94-93dc-bf42a5cf5111",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "a31d7a23-afbe-3d94-93dc-bf42a5cf5111"
                ]
              }
            },
            {
              "id": "ba9fd730-4217-3369-962a-447bfb370b2b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "7ca35e7a-a9af-3573-9ed1-532912aad417",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "1ff9eb98-f827-3d03-b0ee-0f4ef05448b8",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "e9c43a60-3e72-39b2-946a-3738988fb4df",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "e9c43a60-3e72-39b2-946a-3738988fb4df"
                ]
              }
            },
            {
              "id": "3da4398b-cece-390d-a5c4-e4f78ebc1d22",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "3da4398b-cece-390d-a5c4-e4f78ebc1d22"
                ]
              }
            },
            {
              "id": "e9f4cb7c-cf5b-3867-bd18-6522516b9e30",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security risks.\n\nThe specific vulnerability sink in the code `array[i]=rand()%2` is the use of `rand()`, which is a weak random number generator. The `%2` operation further reduces the randomness of the output.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(0, 1);\n\narray[i] = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "e9f4cb7c-cf5b-3867-bd18-6522516b9e30"
                ]
              }
            },
            {
              "id": "9c751251-89ba-3a75-996c-093590eae01d",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "af54602d-fe76-3f7c-aec9-e2802766d1d5",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "10c92dc6-d37f-35da-9460-36949a345bfd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "310ee1b7-e2ef-327c-b3c0-09148f53271a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "0d694e68-61e9-35f4-8f34-cdb50f39235c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nIn C++ programming, the vulnerability \"Avoid Using Weak or Non-Cryptographic Random Number Generators\" refers to the use of weak random number generators or non-cryptographic random number generators in the code. This can lead to predictability in the generated numbers, which can be exploited by attackers to predict the behavior of the program, leading to security risks.\n\nThe specific vulnerability sink in the code `array[i]=rand()%2` is the use of `rand()`, which is a weak random number generator. The `%2` operation further reduces the randomness of the output.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator instead of `rand()`. In C++, you can use the `<random>` library, which provides a variety of random number generators that are more secure and less predictable than `rand()`.\n\n## Source Code Fix Recommendation\n\nHere is a code fix recommendation:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(0, 1);\n\narray[i] = dis(gen);\n```\n\nIn this code, `std::random_device` is a uniformly-distributed integer random number generator that produces non-deterministic random numbers. `std::mt19937` is a Mersenne Twister random number generator, and `std::uniform_int_distribution` produces random integers in a range [a, b].\n\n## Library Dependencies\n\nThe code example requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "0d694e68-61e9-35f4-8f34-cdb50f39235c"
                ]
              }
            },
            {
              "id": "65c2311a-6577-31c8-9402-e0dfbd32d116",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "65c2311a-6577-31c8-9402-e0dfbd32d116"
                ]
              }
            },
            {
              "id": "a4acb710-01c0-3a5d-9515-448ec2c5eba1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "a4acb710-01c0-3a5d-9515-448ec2c5eba1"
                ]
              }
            },
            {
              "id": "d8fe4a24-6f28-3db5-a486-06fa9ee1c4cd",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "98c0c107-f0e3-3bfd-bfdf-ad3a5f885c7e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2e89b844-1aa9-38b5-88cc-5df0709f4369",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflows, format string vulnerabilities, or other problems. One such function is `printf`.\n\nThe `printf` function is a common function in C and C++ for outputting text. However, it can be dangerous if used improperly, especially when handling user-supplied input. This is because `printf` can interpret certain special characters (like `%s`, `%d`, etc.) and if an attacker can control the format string, they can potentially exploit this to execute arbitrary code, read from or write to arbitrary memory locations, or cause the program to crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using `printf` with user-supplied input. Instead, use safer alternatives that do not interpret format strings, such as `puts` or `fputs`. If you need to format strings, use functions like `snprintf` that limit the amount of output, and always use a static format string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(user_input);\n```\n\nUse:\n\n```cpp\nchar* user_input = get_user_input();\nputs(user_input);\n```\n\nOr, if you need to format strings:\n\n```cpp\nchar* user_input = get_user_input();\nchar buffer[256];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input);\nputs(buffer);\n```\n\n## Library Dependencies\n\nThe code examples above require the following library:\n\n```cpp\n#include <stdio.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "375d8a54-854b-3140-b2eb-9255719f7b3e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability in C++ refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, integer overflows, etc. These functions are often prohibited in secure coding standards due to their potential misuse or abuse.\n\nIn the given code sink `argc > 1`, there is no direct use of a prohibited C function. However, `argc` is a parameter in the `main` function that represents the number of command-line arguments passed to the program. If not properly validated, it can lead to vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this potential vulnerability, you should always validate the command-line arguments (`argc` and `argv`) before using them. Ensure that the number of arguments (`argc`) is as expected and that the arguments themselves (`argv`) are valid and safe to use.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how you can validate `argc` and `argv`:\n\n```cpp\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <input>\\n\";\n        return 1;\n    }\n\n    // Now it's safe to use argv[1]\n    std::cout << \"Input: \" << argv[1] << \"\\n\";\n\n    return 0;\n}\n```\n\nIn this example, the program expects exactly one command-line argument (in addition to the program name itself). If the number of arguments is not as expected, the program prints a usage message and exits with a non-zero status code.\n\n## Library Dependencies\n\nThe above code example requires the following library:\n\n- iostream\n\n## References\n\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "09691319-73f8-34f4-8cbe-23a230f914b1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability refers to the use of certain C functions that are considered unsafe due to their potential to cause buffer overflows, format string vulnerabilities, or other security issues. In this case, the function `atoi()` is used, which can lead to integer overflow or underflow if the input is not properly validated.\n\nThe `atoi()` function converts a string to an integer. If the string cannot be converted to an integer, it returns zero. This can lead to unexpected behavior if the input string is not a valid integer. Furthermore, `atoi()` does not check for integer overflow or underflow, which can lead to further unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should replace the `atoi()` function with a safer alternative that checks for errors. The `strtol()` function is a good alternative because it allows you to check for errors such as integer overflow and underflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the code:\n\n```cpp\n#include <cstdlib>\n#include <climits>\n#include <cerrno>\n\nchar *endptr;\nlong val = strtol(argv[1], &endptr, 10);\n\nif ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) || (errno != 0 && val == 0)) {\n    perror(\"strtol\");\n    exit(EXIT_FAILURE);\n}\n\nif (endptr == argv[1]) {\n    fprintf(stderr, \"No digits were found\\n\");\n    exit(EXIT_FAILURE);\n}\n\nARRAYSIZE = val;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `strtol()`, `perror()`, and `exit()`\n- `<climits>` for `LONG_MAX` and `LONG_MIN`\n- `<cerrno>` for `errno`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "2f8c6d28-9ce8-313b-b90f-de1bc80219ea",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "2f8c6d28-9ce8-313b-b90f-de1bc80219ea"
                ]
              }
            },
            {
              "id": "a447ce40-52ee-3385-822f-335dc9cfda22",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions that can lead to various security issues such as buffer overflows, format string vulnerabilities, or integer overflows. In the provided code snippet, the `printf` function is used, which is generally safe. However, if user-controlled input is passed directly into `printf` without a proper format specifier, it can lead to a format string vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, avoid using C library functions that are known to be insecure. If you must use them, ensure that you are using them correctly and safely. For `printf`, always use a static format string. If you need to print user-controlled input, use `%s` and pass the user-controlled input as an argument.\n\n## Source Code Fix Recommendation\n\nThe provided code snippet does not seem to have a vulnerability as it uses a static string with `printf`. However, if user-controlled input was to be printed, it should be done as follows:\n\n```cpp\nchar* user_input = get_user_input();\nprintf(\"%s\", user_input);\n```\n\n## Library Dependencies\n\nThe provided code snippet does not seem to have any library dependencies other than the standard C library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "c91eb799-532b-384e-af2b-c8940f1aff48",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Avoid Using Non-Cryptographic or Weak Random Number Generators\" vulnerability in C++ refers to the use of weak or non-cryptographic random number generators that can lead to predictable or easily guessable values. This can be exploited by an attacker to predict the outcome of the program, leading to a variety of security issues.\n\nIn the provided code snippet, `rand()` is a weak random number generator as it uses a linear congruential generator that can be easily predicted after observing a sequence of generated values.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use a strong, cryptographic random number generator. In C++, this can be achieved using the `<random>` library, which provides a variety of random number generators that are suitable for cryptographic use.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code using the `std::random_device` and `std::uniform_real_distribution` from the `<random>` library:\n\n```cpp\n#include <random>\n\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_real_distribution<> dis(-1.0, 1.0);\n\ndata[i] = 2.0f * dis(gen) - 1.0f;\n```\n\n## Library Dependencies\n\nThe fixed code requires the `<random>` library.\n\n## References\n\n- [CWE-338: Use of Cryptographically Weak PRNG](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264",
                  "c91eb799-532b-384e-af2b-c8940f1aff48"
                ]
              }
            },
            {
              "id": "a471c20e-bdd4-37e2-9030-4d876375dd7e",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to buffer overflow attacks, format string vulnerabilities, integer overflow, etc. In this case, the function `std::atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or that may fail silently. Instead, use safer alternatives provided by the C++ Standard Library. For instance, instead of `std::atoi()`, consider using `std::stoi()` which throws an exception if the conversion fails or if the converted value is out of range.\n\n## Source Code Fix Recommendation\n\nReplace the `std::atoi()` function with `std::stoi()`. Here is the corrected code:\n\n```cpp\ntry {\n    N = std::stoi(optarg);\n} catch (std::invalid_argument& e) {\n    // Handle exception: conversion failed\n} catch (std::out_of_range& e) {\n    // Handle exception: number out of range for int\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>`: For `std::atoi()`.\n- `<string>`: For `std::stoi()`.\n\n## References\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "a45f9f62-aa24-35fe-8902-5bc69088b568",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Detected Prohibited C Function\" vulnerability refers to the use of insecure C library functions in C++ code. These functions are often prone to errors such as buffer overflows, integer overflows, or other vulnerabilities that can lead to serious security issues. In this case, the function `std::atoi()` is used, which can lead to integer overflow or underflow if the input string represents a number outside the range of representable integer values.\n\n## Mitigation Advice\n\nAvoid using C library functions that do not perform bounds checking or that are not safe from integer overflows or underflows. Instead, use safer alternatives provided by the C++ Standard Library. In this case, consider using `std::stoi()` or `std::stol()` functions, which throw an exception if the converted value would fall out of the range of the result type or if the underlying function reports an error.\n\n## Source Code Fix Recommendation\n\nReplace `std::atoi(optarg)` with `std::stoi(optarg)`. Here is the corrected code:\n\n```cpp\ntry {\n    blockSize = std::stoi(optarg);\n} catch (std::out_of_range& e) {\n    std::cerr << \"Error: Block size is out of range.\\n\";\n} catch (std::invalid_argument& e) {\n    std::cerr << \"Error: Invalid block size.\\n\";\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstdlib>` for `std::atoi()`\n- `<string>` for `std::stoi()`\n- `<iostream>` for `std::cerr`\n\n## References\n\n- [CWE-681: Incorrect Conversion between Numeric Types](https://cwe.mitre.org/data/definitions/681.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "de31a6c3-7a66-3214-95ec-7f7d93e68f1d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-soa.c"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 2,
                  "endLine": 80,
                  "endColumn": 8,
                  "charOffset": 2081,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "c0845fa9-c412-351e-b58b-c403a39ed912",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-soa.c"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 2,
                  "endLine": 82,
                  "endColumn": 8,
                  "charOffset": 2192,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "efa97c47-6b33-3c61-8e64-d9c8dd0fc7fa",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-soa.c"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 4,
                  "endLine": 72,
                  "endColumn": 10,
                  "charOffset": 1870,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2c435abc-93f5-31ca-a1a6-c7bfa16f9d52",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-soa.c"
                },
                "region": {
                  "startLine": 41,
                  "startColumn": 26,
                  "endLine": 41,
                  "endColumn": 30,
                  "charOffset": 1019,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "859cb934-6c4b-398d-b849-32bcfca70035",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-block.c"
                },
                "region": {
                  "startLine": 90,
                  "startColumn": 2,
                  "endLine": 90,
                  "endColumn": 8,
                  "charOffset": 2489,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4d63bee9-96b8-3d59-9107-bfbc826e7a34",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-block.c"
                },
                "region": {
                  "startLine": 88,
                  "startColumn": 2,
                  "endLine": 88,
                  "endColumn": 8,
                  "charOffset": 2378,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "18531015-7d71-3110-b3c1-e3c001547eda",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-block.c"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 4,
                  "endLine": 80,
                  "endColumn": 10,
                  "charOffset": 2167,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "cf583bbf-8154-3491-8618-711bbe38e462",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-block.c"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 26,
                  "endLine": 46,
                  "endColumn": 30,
                  "charOffset": 1235,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "adb2987d-f07d-3f00-8e8c-97dc9fd29014",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/RecursiveGaussian/RecursiveGaussian.cpp"
                },
                "region": {
                  "startLine": 195,
                  "startColumn": 4,
                  "endLine": 195,
                  "endColumn": 72,
                  "charOffset": 6732,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(verificationInput, pixelData, width * height * sizeof(uchar4)",
                    "rendered": {
                      "text": "memcpy(verificationInput, pixelData, width * height * sizeof(uchar4)",
                      "markdown": "`memcpy(verificationInput, pixelData, width * height * sizeof(uchar4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/RecursiveGaussian/RecursiveGaussian.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6732,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(verificationInput, <size of verificationInput>,  pixelData,  width * height * sizeof(uchar4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5dc1c22a-ef0a-344c-b8cd-149b7ed2e9af",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/RecursiveGaussian/RecursiveGaussian.cpp"
                },
                "region": {
                  "startLine": 214,
                  "startColumn": 4,
                  "endLine": 214,
                  "endColumn": 70,
                  "charOffset": 7307,
                  "charLength": 66,
                  "snippet": {
                    "text": "memcpy(pixelData, outputImageData, width * height * sizeof(uchar4)",
                    "rendered": {
                      "text": "memcpy(pixelData, outputImageData, width * height * sizeof(uchar4)",
                      "markdown": "`memcpy(pixelData, outputImageData, width * height * sizeof(uchar4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/RecursiveGaussian/RecursiveGaussian.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7307,
                        "charLength": 66
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pixelData, <size of pixelData>,  outputImageData,  width * height * sizeof(uchar4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "cdac9135-01ed-3449-a97e-0d84db7b8859",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                },
                "region": {
                  "startLine": 457,
                  "startColumn": 24,
                  "endLine": 457,
                  "endColumn": 29,
                  "charOffset": 15163,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "896c7706-9273-360b-9ef9-83f34c1d4927",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                },
                "region": {
                  "startLine": 236,
                  "startColumn": 24,
                  "endLine": 236,
                  "endColumn": 29,
                  "charOffset": 7271,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "657f24db-243f-3b47-948b-f210acfece66",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                },
                "region": {
                  "startLine": 381,
                  "startColumn": 24,
                  "endLine": 381,
                  "endColumn": 29,
                  "charOffset": 12490,
                  "charLength": 5,
                  "snippet": {
                    "text": "fopen",
                    "rendered": {
                      "text": "fopen",
                      "markdown": "`fopen`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a46067e5-a312-33dc-9e85-1e730c1ef069",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/RecursiveGaussian/RecursiveGaussian.cpp"
                },
                "region": {
                  "startLine": 194,
                  "startColumn": 4,
                  "endLine": 194,
                  "endColumn": 69,
                  "charOffset": 6660,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy(inputImageData, pixelData, width * height * sizeof(uchar4)",
                    "rendered": {
                      "text": "memcpy(inputImageData, pixelData, width * height * sizeof(uchar4)",
                      "markdown": "`memcpy(inputImageData, pixelData, width * height * sizeof(uchar4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/RecursiveGaussian/RecursiveGaussian.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6660,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s(inputImageData, <size of inputImageData>,  pixelData,  width * height * sizeof(uchar4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "e1bc17f0-7430-3b94-9a1d-170d70e54fdb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 20,
                  "endLine": 205,
                  "endColumn": 82,
                  "charOffset": 6182,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(colors_, rhs.colors_, numColors_ * sizeof(ColorPalette)",
                    "rendered": {
                      "text": "memcpy(colors_, rhs.colors_, numColors_ * sizeof(ColorPalette)",
                      "markdown": "`memcpy(colors_, rhs.colors_, numColors_ * sizeof(ColorPalette)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6182,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(colors_, <size of colors_>,  rhs.colors_,  numColors_ * sizeof(ColorPalette)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7cce925e-12f3-3de9-9bb2-f2046cf35b91",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                },
                "region": {
                  "startLine": 215,
                  "startColumn": 16,
                  "endLine": 215,
                  "endColumn": 76,
                  "charOffset": 6557,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(pixels_, rhs.pixels_, width * height * sizeof(uchar4)",
                    "rendered": {
                      "text": "memcpy(pixels_, rhs.pixels_, width * height * sizeof(uchar4)",
                      "markdown": "`memcpy(pixels_, rhs.pixels_, width * height * sizeof(uchar4)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/include/SDKBitMap.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6557,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pixels_, <size of pixels_>,  rhs.pixels_,  width * height * sizeof(uchar4)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "3274618e-baf0-370b-b251-6c4d6a5c4d4c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 2426,
                  "startColumn": 40,
                  "endLine": 2426,
                  "endColumn": 46,
                  "charOffset": 67289,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1dbf07a0-eb8b-3e8f-b359-4c635747bba0",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 2401,
                  "startColumn": 46,
                  "endLine": 2401,
                  "endColumn": 52,
                  "charOffset": 66540,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "df07884d-93a7-34c6-9467-8a83c66d2caf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 2400,
                  "startColumn": 40,
                  "endLine": 2400,
                  "endColumn": 46,
                  "charOffset": 66464,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8234c028-c19b-32ba-94a7-7a6977ef0379",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 2979,
                  "startColumn": 24,
                  "endLine": 2979,
                  "endColumn": 30,
                  "charOffset": 85768,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3b30307c-dec9-333a-a9e9-9fa0af3def11",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 1399,
                  "startColumn": 48,
                  "endLine": 1399,
                  "endColumn": 54,
                  "charOffset": 42366,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "02b7fac2-a129-32aa-acd6-7ad54a4b1c25",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 2529,
                  "startColumn": 34,
                  "endLine": 2529,
                  "endColumn": 40,
                  "charOffset": 70514,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f9f319d8-4139-35d7-b6b2-dbf880c86975",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 2427,
                  "startColumn": 63,
                  "endLine": 2427,
                  "endColumn": 69,
                  "charOffset": 67382,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f434acd3-f4cf-30e0-b397-5a0557706911",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 1515,
                  "startColumn": 12,
                  "endLine": 1515,
                  "endColumn": 18,
                  "charOffset": 45449,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "bdc43e77-c7f9-30c9-8a14-76772732574f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 1372,
                  "startColumn": 44,
                  "endLine": 1372,
                  "endColumn": 50,
                  "charOffset": 41624,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "5f6b5954-6eaf-37fd-b8fa-7c7368243371",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 1307,
                  "startColumn": 44,
                  "endLine": 1307,
                  "endColumn": 50,
                  "charOffset": 39277,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "014b0329-2da0-3822-b493-1d22b2ac370f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 1243,
                  "startColumn": 44,
                  "endLine": 1243,
                  "endColumn": 50,
                  "charOffset": 37482,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "aef116ff-fdbf-39dd-95cb-308a3fabef66",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 506,
                  "startColumn": 12,
                  "endLine": 506,
                  "endColumn": 51,
                  "charOffset": 15201,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(&data_[0], &rhs.data_[0], size()",
                    "rendered": {
                      "text": "memcpy(&data_[0], &rhs.data_[0], size()",
                      "markdown": "`memcpy(&data_[0], &rhs.data_[0], size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15201,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data_[0], <size of &data_[0]>,  &rhs.data_[0],  size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "b6e1db2c-59f7-33e8-9a93-80ad5ae93d53",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 749,
                  "startColumn": 30,
                  "endLine": 749,
                  "endColumn": 36,
                  "charOffset": 20043,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d48526f7-13ee-3115-89bb-292ac1c11a74",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 710,
                  "startColumn": 24,
                  "endLine": 710,
                  "endColumn": 30,
                  "charOffset": 19055,
                  "charLength": 6,
                  "snippet": {
                    "text": "alloca",
                    "rendered": {
                      "text": "alloca",
                      "markdown": "`alloca`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "4bf084ad-84c3-3627-b5f3-f927b7bb5a8a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 483,
                  "startColumn": 12,
                  "endLine": 483,
                  "endColumn": 51,
                  "charOffset": 14718,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(&data_[0], &vec.data_[0], size()",
                    "rendered": {
                      "text": "memcpy(&data_[0], &vec.data_[0], size()",
                      "markdown": "`memcpy(&data_[0], &vec.data_[0], size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14718,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&data_[0], <size of &data_[0]>,  &vec.data_[0],  size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "78389e7f-e4ab-3180-be6c-dd501a78f4ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 382,
                  "startColumn": 16,
                  "endLine": 382,
                  "endColumn": 50,
                  "charOffset": 12776,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(str_, rhs.str_, (size_ + 1)",
                    "rendered": {
                      "text": "memcpy(str_, rhs.str_, (size_ + 1)",
                      "markdown": "`memcpy(str_, rhs.str_, (size_ + 1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12776,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(str_, <size of str_>,  rhs.str_,  (size_ + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "a341c91e-334a-3dc1-8cd8-dd2f04ff1c67",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 358,
                  "startColumn": 17,
                  "endLine": 358,
                  "endColumn": 28,
                  "charOffset": 12219,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12219,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12219,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7e17b001-d0f5-379d-93be-dd4b8fc956b8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 12,
                  "endLine": 347,
                  "endColumn": 51,
                  "charOffset": 12013,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(str_, str, size_  * sizeof(char)",
                    "rendered": {
                      "text": "memcpy(str_, str, size_  * sizeof(char)",
                      "markdown": "`memcpy(str_, str, size_  * sizeof(char)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12013,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(str_, <size of str_>,  str,  size_  * sizeof(char)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5bce0b92-f0db-3ed4-8840-c85dcbe9ed0e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/FloydWarshall/FloydWarshall.cpp"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 8,
                  "endLine": 299,
                  "endColumn": 80,
                  "charOffset": 10269,
                  "charLength": 72,
                  "snippet": {
                    "text": "memcpy(verificationPathMatrix, pathMatrix, numNodes*numNodes*sizeof(int)",
                    "rendered": {
                      "text": "memcpy(verificationPathMatrix, pathMatrix, numNodes*numNodes*sizeof(int)",
                      "markdown": "`memcpy(verificationPathMatrix, pathMatrix, numNodes*numNodes*sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/FloydWarshall/FloydWarshall.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10269,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "memcpy_s(verificationPathMatrix, <size of verificationPathMatrix>,  pathMatrix,  numNodes*numNodes*sizeof(int)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5daf7c9b-f39e-30bd-920e-bb55df50e191",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/FloydWarshall/FloydWarshall.cpp"
                },
                "region": {
                  "startLine": 297,
                  "startColumn": 8,
                  "endLine": 298,
                  "endColumn": 48,
                  "charOffset": 10151,
                  "charLength": 107,
                  "snippet": {
                    "text": "memcpy(verificationPathDistanceMatrix, pathDistanceMatrix,\n               numNodes * numNodes * sizeof(int)",
                    "rendered": {
                      "text": "memcpy(verificationPathDistanceMatrix, pathDistanceMatrix,\n               numNodes * numNodes * sizeof(int)",
                      "markdown": "`memcpy(verificationPathDistanceMatrix, pathDistanceMatrix,\n               numNodes * numNodes * sizeof(int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/FloydWarshall/FloydWarshall.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10151,
                        "charLength": 107
                      },
                      "insertedContent": {
                        "text": "memcpy_s(verificationPathDistanceMatrix, <size of verificationPathDistanceMatrix>,  pathDistanceMatrix, \n               numNodes * numNodes * sizeof(int)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "7be40671-7dc9-37fb-a13d-0d3e69eafd88",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/BitonicSort/BitonicSort.cpp"
                },
                "region": {
                  "startLine": 231,
                  "startColumn": 8,
                  "endLine": 231,
                  "endColumn": 70,
                  "charOffset": 7553,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(verificationInput, input, length * sizeof(unsigned int)",
                    "rendered": {
                      "text": "memcpy(verificationInput, input, length * sizeof(unsigned int)",
                      "markdown": "`memcpy(verificationInput, input, length * sizeof(unsigned int)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/BitonicSort/BitonicSort.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7553,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(verificationInput, <size of verificationInput>,  input,  length * sizeof(unsigned int)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "65be0994-4c81-3925-b816-da30fbd5e3bf",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/include/SDKFile.hpp"
                },
                "region": {
                  "startLine": 154,
                  "startColumn": 12,
                  "endLine": 154,
                  "endColumn": 18,
                  "charOffset": 4757,
                  "charLength": 6,
                  "snippet": {
                    "text": "rewind",
                    "rendered": {
                      "text": "rewind",
                      "markdown": "`rewind`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ca1f7154-4a7c-34c6-b012-bda15b8e7f7b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/HelloWorld/HelloWorld.cpp"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 20,
                  "endLine": 54,
                  "endColumn": 33,
                  "charOffset": 1913,
                  "charLength": 13,
                  "snippet": {
                    "text": "strlen(input)",
                    "rendered": {
                      "text": "strlen(input)",
                      "markdown": "`strlen(input)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/HelloWorld/HelloWorld.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1913,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strlen_s(input, <size of input>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/HelloWorld/HelloWorld.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1913,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strnlen(input, <size of input>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "077cd707-86e3-39a9-b6b1-8a6e059c88ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "add4/common.cpp"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 12,
                  "endLine": 75,
                  "endColumn": 24,
                  "charOffset": 2820,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(next)",
                    "rendered": {
                      "text": "strlen(next)",
                      "markdown": "`strlen(next)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "add4/common.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2820,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(next, <size of next>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "add4/common.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2820,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(next, <size of next>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "9adedea7-29b3-3dec-895d-3ed4efcdb7fc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "add4/common.cpp"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 12,
                  "endLine": 57,
                  "endColumn": 24,
                  "charOffset": 2493,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(next)",
                    "rendered": {
                      "text": "strlen(next)",
                      "markdown": "`strlen(next)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "add4/common.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2493,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(next, <size of next>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "add4/common.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2493,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(next, <size of next>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "ccf189b0-fbfa-38b5-926b-7746cf6da3b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/FastWalshTransform/FastWalshTransform.cpp"
                },
                "region": {
                  "startLine": 155,
                  "startColumn": 8,
                  "endLine": 155,
                  "endColumn": 56,
                  "charOffset": 4897,
                  "charLength": 48,
                  "snippet": {
                    "text": "memcpy(verificationInput, input, inputSizeBytes)",
                    "rendered": {
                      "text": "memcpy(verificationInput, input, inputSizeBytes)",
                      "markdown": "`memcpy(verificationInput, input, inputSizeBytes)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/FastWalshTransform/FastWalshTransform.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4897,
                        "charLength": 48
                      },
                      "insertedContent": {
                        "text": "memcpy_s(verificationInput, <size of verificationInput>,  input,  inputSizeBytes)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "01fbc6ce-91fd-3a34-aff8-9db0aa0a8ca1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "add4/common.cpp"
                },
                "region": {
                  "startLine": 64,
                  "startColumn": 9,
                  "endLine": 64,
                  "endColumn": 20,
                  "charOffset": 2623,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "add4/common.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2623,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "add4/common.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2623,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "d32e157e-9030-3aab-a960-10e50e392f5b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "strided-access/CL/cl.hpp"
                },
                "region": {
                  "startLine": 361,
                  "startColumn": 12,
                  "endLine": 361,
                  "endColumn": 41,
                  "charOffset": 12308,
                  "charLength": 29,
                  "snippet": {
                    "text": "memcpy(str_, str, (size_ + 1)",
                    "rendered": {
                      "text": "memcpy(str_, str, (size_ + 1)",
                      "markdown": "`memcpy(str_, str, (size_ + 1)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "strided-access/CL/cl.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12308,
                        "charLength": 29
                      },
                      "insertedContent": {
                        "text": "memcpy_s(str_, <size of str_>,  str,  (size_ + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "5b82f7ec-b5b4-341b-894a-5fcef5251c0a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 490,
                  "startColumn": 12,
                  "endLine": 490,
                  "endColumn": 59,
                  "charOffset": 15613,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(inData, dPartialOutData, (one << levels)",
                    "rendered": {
                      "text": "memcpy(inData, dPartialOutData, (one << levels)",
                      "markdown": "`memcpy(inData, dPartialOutData, (one << levels)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15613,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(inData, <size of inData>,  dPartialOutData,  (one << levels)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "4b426ba1-bc5a-359f-80a9-3871186f95ff",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 482,
                  "startColumn": 12,
                  "endLine": 483,
                  "endColumn": 54,
                  "charOffset": 15292,
                  "charLength": 123,
                  "snippet": {
                    "text": "memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels),\n                   (signalLength  - (one << curLevels)",
                    "rendered": {
                      "text": "memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels),\n                   (signalLength  - (one << curLevels)",
                      "markdown": "`memcpy(dOutData + (one << curLevels), hOutData + (one << curLevels),\n                   (signalLength  - (one << curLevels)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15292,
                        "charLength": 123
                      },
                      "insertedContent": {
                        "text": "memcpy_s(dOutData + (one << curLevels), <size of dOutData + (one << curLevels)>,  hOutData + (one << curLevels), \n                   (signalLength  - (one << curLevels)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "c7ca8ffe-3993-3d89-b8c5-03999cf64ac9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 497,
                  "startColumn": 4,
                  "endLine": 497,
                  "endColumn": 53,
                  "charOffset": 15752,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(inData, temp, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(inData, temp, signalLength * sizeof(float)",
                      "markdown": "`memcpy(inData, temp, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15752,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(inData, <size of inData>,  temp,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "190058a1-2f82-34be-a2f1-580453a45bcf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 12,
                  "endLine": 489,
                  "endColumn": 70,
                  "charOffset": 15540,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(hOutData, dOutData, curSignalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(hOutData, dOutData, curSignalLength * sizeof(float)",
                      "markdown": "`memcpy(hOutData, dOutData, curSignalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15540,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hOutData, <size of hOutData>,  dOutData,  curSignalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "627e95ee-e40d-3517-901e-e4465b2609ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 4,
                  "endLine": 454,
                  "endColumn": 53,
                  "charOffset": 14523,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(temp, inData, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(temp, inData, signalLength * sizeof(float)",
                      "markdown": "`memcpy(temp, inData, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14523,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(temp, <size of temp>,  inData,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "367972c5-6b50-3669-a424-8aad135482df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 481,
                  "startColumn": 12,
                  "endLine": 481,
                  "endColumn": 57,
                  "charOffset": 15216,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(hOutData, dOutData, (one << curLevels)",
                    "rendered": {
                      "text": "memcpy(hOutData, dOutData, (one << curLevels)",
                      "markdown": "`memcpy(hOutData, dOutData, (one << curLevels)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15216,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(hOutData, <size of hOutData>,  dOutData,  (one << curLevels)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2272aa5e-56ac-316b-9781-8a9ebbddffa9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 453,
                  "startColumn": 26,
                  "endLine": 453,
                  "endColumn": 61,
                  "charOffset": 14481,
                  "charLength": 35,
                  "snippet": {
                    "text": "malloc(signalLength * sizeof(float)",
                    "rendered": {
                      "text": "malloc(signalLength * sizeof(float)",
                      "markdown": "`malloc(signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14481,
                        "charLength": 35
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "2984cf55-33e9-3a44-973a-cab8ca44ff8b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 304,
                  "startColumn": 8,
                  "endLine": 304,
                  "endColumn": 66,
                  "charOffset": 10322,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(tempOutData, hOutData, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(tempOutData, hOutData, signalLength * sizeof(float)",
                      "markdown": "`memcpy(tempOutData, hOutData, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10322,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tempOutData, <size of tempOutData>,  hOutData,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "1c585d4d-b907-3e06-a26e-ff1a84d90d64",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                },
                "region": {
                  "startLine": 285,
                  "startColumn": 4,
                  "endLine": 285,
                  "endColumn": 60,
                  "charOffset": 9714,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(tempOutData, inData, signalLength * sizeof(float)",
                    "rendered": {
                      "text": "memcpy(tempOutData, inData, signalLength * sizeof(float)",
                      "markdown": "`memcpy(tempOutData, inData, signalLength * sizeof(float)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "HIP-Examples-Applications/dwtHaar1D/dwtHaar1D.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9714,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(tempOutData, <size of tempOutData>,  inData,  signalLength * sizeof(float)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "545a8ea5-2ffa-31d1-951b-dc1d2a900e8a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "gpu-burn/gpuburn.cpp"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 26,
                  "endLine": 114,
                  "endColumn": 30,
                  "charOffset": 3009,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9a1aa80b-e015-3267-853c-d9009b1560a1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-soa.cpp"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 2,
                  "endLine": 89,
                  "endColumn": 8,
                  "charOffset": 2538,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a8149971-b308-3c50-a36e-b37210f8df9b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-soa.cpp"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 2,
                  "endLine": 87,
                  "endColumn": 8,
                  "charOffset": 2427,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9eee11fa-02de-36dc-955f-1530c44f795f",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-soa.cpp"
                },
                "region": {
                  "startLine": 79,
                  "startColumn": 4,
                  "endLine": 79,
                  "endColumn": 10,
                  "charOffset": 2217,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "8d4ed873-8b5b-30bb-8952-ede73f2f7d66",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-soa.cpp"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 26,
                  "endLine": 43,
                  "endColumn": 30,
                  "charOffset": 1107,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "baa2ea4e-6b48-3576-86bc-1b3d002e8ee1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/nbody.c"
                },
                "region": {
                  "startLine": 78,
                  "startColumn": 2,
                  "endLine": 78,
                  "endColumn": 8,
                  "charOffset": 2042,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "3b804fcb-fcdb-344b-b888-b96885fbd87d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/nbody.c"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 2,
                  "endLine": 76,
                  "endColumn": 8,
                  "charOffset": 1931,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "29eeda33-9799-3a5a-a1b7-65ae8121184e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/nbody.c"
                },
                "region": {
                  "startLine": 68,
                  "startColumn": 4,
                  "endLine": 68,
                  "endColumn": 10,
                  "charOffset": 1720,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "f19b27c3-52ca-3b1a-9dd9-3afd6338cdb4",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/nbody.c"
                },
                "region": {
                  "startLine": 39,
                  "startColumn": 26,
                  "endLine": 39,
                  "endColumn": 30,
                  "charOffset": 1000,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "ba9fd730-4217-3369-962a-447bfb370b2b",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-orig.cpp"
                },
                "region": {
                  "startLine": 93,
                  "startColumn": 2,
                  "endLine": 93,
                  "endColumn": 8,
                  "charOffset": 2562,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "7ca35e7a-a9af-3573-9ed1-532912aad417",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-orig.cpp"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 4,
                  "endLine": 83,
                  "endColumn": 10,
                  "charOffset": 2237,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "1ff9eb98-f827-3d03-b0ee-0f4ef05448b8",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-orig.cpp"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 26,
                  "endLine": 47,
                  "endColumn": 30,
                  "charOffset": 1213,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "9c751251-89ba-3a75-996c-093590eae01d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-block.cpp"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 2,
                  "endLine": 96,
                  "endColumn": 8,
                  "charOffset": 2808,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "af54602d-fe76-3f7c-aec9-e2802766d1d5",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-block.cpp"
                },
                "region": {
                  "startLine": 94,
                  "startColumn": 2,
                  "endLine": 94,
                  "endColumn": 8,
                  "charOffset": 2697,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "10c92dc6-d37f-35da-9460-36949a345bfd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-block.cpp"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 4,
                  "endLine": 86,
                  "endColumn": 10,
                  "charOffset": 2487,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "310ee1b7-e2ef-327c-b3c0-09148f53271a",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/hip/nbody-block.cpp"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 26,
                  "endLine": 50,
                  "endColumn": 30,
                  "charOffset": 1377,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "d8fe4a24-6f28-3db5-a486-06fa9ee1c4cd",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-align.c"
                },
                "region": {
                  "startLine": 97,
                  "startColumn": 2,
                  "endLine": 97,
                  "endColumn": 8,
                  "charOffset": 2717,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "98c0c107-f0e3-3bfd-bfdf-ad3a5f885c7e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-align.c"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 2,
                  "endLine": 95,
                  "endColumn": 8,
                  "charOffset": 2606,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "2e89b844-1aa9-38b5-88cc-5df0709f4369",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-align.c"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 4,
                  "endLine": 87,
                  "endColumn": 10,
                  "charOffset": 2395,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "375d8a54-854b-3140-b2eb-9255719f7b3e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mini-nbody/mic/nbody-align.c"
                },
                "region": {
                  "startLine": 48,
                  "startColumn": 26,
                  "endLine": 48,
                  "endColumn": 30,
                  "charOffset": 1283,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "09691319-73f8-34f4-8cbe-23a230f914b1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "\"Prohibited C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "reduction/reduction.cpp"
                },
                "region": {
                  "startLine": 82,
                  "startColumn": 18,
                  "endLine": 82,
                  "endColumn": 22,
                  "charOffset": 2727,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a447ce40-52ee-3385-822f-335dc9cfda22",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "cuda-stream/stream.cpp"
                },
                "region": {
                  "startLine": 51,
                  "startColumn": 4,
                  "endLine": 51,
                  "endColumn": 10,
                  "charOffset": 1002,
                  "charLength": 6,
                  "snippet": {
                    "text": "printf",
                    "rendered": {
                      "text": "printf",
                      "markdown": "`printf`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a471c20e-bdd4-37e2-9030-4d876375dd7e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "cuda-stream/stream.cpp"
                },
                "region": {
                  "startLine": 80,
                  "startColumn": 25,
                  "endLine": 80,
                  "endColumn": 29,
                  "charOffset": 1818,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "a45f9f62-aa24-35fe-8902-5bc69088b568",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Detected Prohibited C Function"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "cuda-stream/stream.cpp"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 33,
                  "endLine": 83,
                  "endColumn": 37,
                  "charOffset": 1910,
                  "charLength": 4,
                  "snippet": {
                    "text": "atoi",
                    "rendered": {
                      "text": "atoi",
                      "markdown": "`atoi`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}